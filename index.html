<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Advanced Trading Bot for Polygon Network">
  <title>Trading Bot Dashboard</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    /* Reset and Global Styles */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', sans-serif;
      background-color: #1a1a1a;
      color: #e0e0e0;
      line-height: 1.5;
      font-size: 16px;
    }

    .container {
      display: flex;
      min-height: 100vh;
    }

    /* Sidebar */
    .sidebar {
      width: 280px;
      background-color: #222222;
      padding: 20px;
      transition: transform 0.3s ease;
      border-right: 1px solid #333;
    }

    .sidebar-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    .sidebar-header h1 {
      font-size: 24px;
      font-weight: 600;
    }

    .sidebar-toggle {
      background: none;
      border: none;
      color: #e0e0e0;
      font-size: 24px;
      cursor: pointer;
    }

    .main-toggle {
      background: none;
      border: none;
      color: #e0e0e0;
      font-size: 24px;
      cursor: pointer;
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 1001;
      display: none;
    }

    .wallet-section, .contract-status, .timeframe-section {
      margin-bottom: 20px;
    }

    .wallet-section p, .contract-status p, .timeframe-section p {
      font-size: 14px;
      margin-top: 10px;
    }

    .contract-status .btn {
      margin-top: 10px;
    }

    .timeframe-section select {
      width: 100%;
      padding: 8px;
      border-radius: 4px;
      background: #333;
      color: #e0e0e0;
      border: 1px solid #444;
    }

    /* Main Content */
    .main-content {
      flex: 1;
      padding: 20px;
      overflow-y: auto;
      position: relative;
    }

    .dashboard-header {
      margin-bottom: 20px;
    }

    .dashboard-header h2 {
      font-size: 28px;
      font-weight: 600;
    }

    .dashboard-header p {
      font-size: 14px;
      color: #a0a0a0;
    }

    /* Card */
    .card {
      background: #252525;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 20px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .card h3 {
      font-size: 20px;
      font-weight: 600;
      margin-bottom: 15px;
    }

    /* Form Grid */
    .form-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
    }

    .form-group {
      display: flex;
      flex-direction: column;
    }

    .form-group label {
      font-size: 14px;
      margin-bottom: 5px;
      color: #a0a0a0;
    }

    .form-group input, .form-group select {
      padding: 10px;
      border-radius: 4px;
      border: 1px solid #444;
      background: #333;
      color: #e0e0e0;
      font-size: 14px;
      transition: border-color 0.2s;
    }

    .form-group input:focus, .form-group select:focus {
      outline: none;
      border-color: #007bff;
    }

    .form-group p {
      font-size: 12px;
      color: #a0a0a0;
      margin-top: 5px;
    }

    /* Buttons */
    .btn {
      padding: 10px 20px;
      border: none;
      border-radius: 4px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: background-color 0.2s, transform 0.1s;
    }

    .btn-primary {
      background-color: #007bff;
      color: #fff;
    }

    .btn-primary:hover {
      background-color: #0056b3;
    }

    .btn-secondary {
      background-color: #444;
      color: #e0e0e0;
    }

    .btn-secondary:hover {
      background-color: #555;
    }

    /* Chart Section */
    .chart-section {
      display: flex;
      flex-direction: column;
      gap: 20px;
      margin-top: 20px;
    }

    .chart-container {
      display: flex;
      justify-content: space-between;
      gap: 20px;
    }

    .chart-container > div {
      flex: 1;
    }

    iframe {
      width: 100%;
      height: 500px;
      border: none;
    }

    @media (max-width: 768px) {
      .container {
        flex-direction: column;
      }

      .sidebar {
        width: 100%;
        position: fixed;
        top: 0;
        left: 0;
        z-index: 1000;
        height: 100%;
        transform: translateX(0);
        transition: transform 0.3s ease;
      }

      .sidebar.hidden {
        transform: translateX(-100%);
      }

      .main-content {
        padding: 10px;
        margin-top: 0;
        overflow: auto;
      }

      .form-grid {
        grid-template-columns: 1fr;
      }

      .chart-container {
        flex-direction: column;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <h1>Trading Bot</h1>
        <button class="sidebar-toggle" aria-label="Toggle Sidebar" onclick="toggleSidebar()">☰</button>
      </div>
      <div class="wallet-section">
        <button id="connectButton" class="btn btn-primary" onclick="connectWallet()">Connect Wallet</button>
        <button id="disconnectButton" class="btn btn-secondary" onclick="disconnectWallet()" style="display: none;">Disconnect Wallet</button>
        <p id="walletStatus">Wallet: Not Connected</p>
        <p id="nativeBalance">Native Balance: 0 MATIC</p>
        <p id="pnlStatus">PnL: $0.00 (Since 12:00 AM WAT)</p>
      </div>
      <div class="contract-status">
        <p id="contractStatus">Contract Status: Active</p>
        <button id="pauseButton" class="btn btn-danger" onclick="pauseContract()">Pause Contract</button>
        <button id="unpauseButton" class="btn btn-success" onclick="unpauseContract()" style="display: none;">Unpause Contract</button>
      </div>
      <div class="timeframe-section">
        <label for="timeframe">Timeframe:</label>
        <select id="timeframe" onchange="setTimeframe()">
          <option value="1m">1 Minute</option>
          <option value="5m" selected>5 Minutes</option>
          <option value="15m">15 Minutes</option>
          <option value="1h">1 Hour</option>
        </select>
      </div>
    </aside>

    <!-- Main Content -->
    <main class="main-content">
      <button class="main-toggle" aria-label="Toggle Sidebar" onclick="toggleSidebar()">☰</button>
      <header class="dashboard-header">
        <h2>Dashboard</h2>
        <p id="currentPair">Current Pair: Not Set</p>
        <p id="priceStatus">Prices: Loading...</p>
      </header>

      <!-- Token Selection -->
      <section class="card token-selection">
        <h3>Token Pair</h3>
        <div class="form-grid">
          <div class="form-group">
            <label for="tokenIn">Token In:</label>
            <select id="tokenIn" onchange="updateTokenDropdowns()"></select>
            <input type="text" id="customTokenIn" placeholder="Custom Token Address">
            <button onclick="addCustomToken('In')">Add Custom</button>
            <p id="tokenInInfo">Balance: 0.0000 | Value: $0.00</p>
          </div>
          <div class="form-group">
            <label for="tokenOut">Token Out:</label>
            <select id="tokenOut" onchange="updateTokenDropdowns()"></select>
            <input type="text" id="customTokenOut" placeholder="Custom Token Address">
            <button onclick="addCustomToken('Out')">Add Custom</button>
            <p id="tokenOutInfo">Balance: 0.0000 | Value: $0.00</p>
          </div>
          <div class="form-group">
            <label for="priceFeedIn">Price Feed In:</label>
            <select id="priceFeedIn"></select>
            <input type="text" id="customPriceFeedIn" placeholder="Custom Price Feed Address">
            <button onclick="addCustomPriceFeed('In')">Add Custom</button>
          </div>
          <div class="form-group">
            <label for="priceFeedOut">Price Feed Out:</label>
            <select id="priceFeedOut"></select>
            <input type="text" id="customPriceFeedOut" placeholder="Custom Price Feed Address">
            <button onclick="addCustomPriceFeed('Out')">Add Custom</button>
          </div>
        </div>
        <button class="btn btn-secondary" onclick="setTokens()">Set Tokens</button>
        <button class="btn btn-secondary" onclick="setPriceFeeds()">Set Price Feeds</button>
      </section>

      <!-- Market Charts -->
      <section class="card chart-section" id="marketCharts">
        <h3>Market Charts</h3>
        <div class="chart-container">
          <div>
            <h4 id="chartTokenInLabel">Select Token In to view Chart</h4>
            <div id="chartTokenIn"></div>
          </div>
          <div>
            <h4 id="chartTokenOutLabel">Select Token Out to view Chart</h4>
            <div id="chartTokenOut"></div>
          </div>
        </div>
        <button class="btn btn-secondary" onclick="refreshCharts()">Refresh Charts</button>
        <button class="btn btn-secondary" onclick="toggleCharts()">Hide Charts</button>
      </section>

      <!-- Funding Actions -->
      <section class="card funding-actions">
        <h3>Funding</h3>
        <div class="form-grid">
          <div class="form-group">
            <label for="budgetToken">Budget Token:</label>
            <select id="budgetToken"></select>
            <label for="budgetAmount">Amount:</label>
            <input type="number" id="budgetAmount" value="0" min="0" step="0.01">
            <button class="btn btn-secondary" onclick="approveBudget()">Approve Budget</button>
            <button class="btn btn-danger" onclick="revokeBudget()">Revoke Budget</button>
            <p id="budgetStatus">Budget: 0 MATIC</p>
          </div>
        </div>
      </section>

      <!-- Transaction Log Table -->
      <section class="card log-area">
        <h3>Transaction Logs</h3>
        <table id="transactionLog">
          <thead>
            <tr>
              <th>Timestamp</th>
              <th>Event</th>
              <th>Details</th>
              <th>Transaction Hash</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </section>
    </main>
  </div>

  <script type="text/javascript">
    const CONTRACT_ADDRESS = '0x56672b9dde9d6d10cd5dd10fc8579a425c24ac02';
    const QUICKSWAP_ROUTER = '0xa5E0829CaCEd8fFDD4De3c43696c57F7D7A678ff';
    const NATIVE_ADDRESS = '0x0000000000000000000000000000000000000000';
    const POLYGONSCAN_URL = 'https://polygonscan.com/tx/';
    const ADDRESS_REGEX = /^0x[0-9a-fA-F]{40}$/;

    // Predefined tokens with symbols
    const TOKENS = [
      { name: 'USDT', address: '0xc2132D05D31c914a87C6611C10748AEb04B58e8F', decimals: 6, coingeckoId: 'tether', symbol: 'USDT' },
      { name: 'USDC', address: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174', decimals: 6, coingeckoId: 'usd-coin', symbol: 'USDC' },
      { name: 'DAI', address: '0x8f3Cf7ad23Cd3CaDbD9735AFf958023239c6A063', decimals: 18, coingeckoId: 'dai', symbol: 'DAI' },
      { name: 'POL', address: '0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270', decimals: 18, coingeckoId: 'matic-network', symbol: 'POL' },
      { name: 'ADA', address: '0xE6a991fF0bf2C1a599c7057b7865b03aC15bF4B2', decimals: 18, coingeckoId: 'cardano', symbol: 'ADA' },
      { name: 'MKR', address: '0x6f7C932e7684666C9fd1d44527765433e01fF61d', decimals: 18, coingeckoId: 'maker', symbol: 'MKR' },
      { name: 'WETH', address: '0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619', decimals: 18, coingeckoId: 'weth', symbol: 'WETH' },
      { name: 'WBTC', address: '0x1BFD67037B42Cf73acF2047067bd4F2C47D9BfD6', decimals: 8, coingeckoId: 'wrapped-bitcoin', symbol: 'WBTC' }
    ];

    // Predefined price feeds
    const PRICE_FEEDS = [
      { name: 'USDT / USD', address: '0x0A6513e40db6EB1b165753AD52E80663aeA50545', asset: 'Tether USD' },
      { name: 'USDC / USD', address: '0xfE4A8cc5b5B2366C1B58Bea3858e81843581b2F7', asset: 'Circle USD' },
      { name: 'DAI / USD', address: '0x4746DeC9e833A82EC7C2C1356372CcF2cfcD2F3D', asset: 'DAI' },
      { name: 'MATIC / USD', address: '0xAB594600376Ec9fD91F8e885dADF0CE036862dE0', asset: 'Polygon' },
      { name: 'ADA / USD', address: '0x882554df528115a743c4537828DA8D5B58e52544', asset: 'Cardano' },
      { name: 'MKR / USD', address: '0xa070427bF5bA5709f70e98b94Cb2F435a242C46C', asset: 'Maker' },
      { name: 'ETH / USD', address: '0xF9680D99D6C9589e2a93a78A04A279e509205945', asset: 'Ethereum' },
      { name: 'WBTC / USD', address: '0xDE31F8bFBD8c84b5360CFACCa3539B938dd78ae6', asset: 'Wrapped Bitcoin' }
    ];

    // Global state
    let web3 = new Web3('https://polygon-rpc.com/');
    let account, contract;
    let tokenIn, tokenOut, priceFeedIn, priceFeedOut, tokenInDecimals, tokenOutDecimals;
    let autoTradingActive = false;
    let autoTradingInterval;
    let dailyPnL = 0;
    let lastPnLReset = 0;

    // Contract ABI
    const CONTRACT_ABI = [
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "_router",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "_wrappedNative",
				"type": "address"
			}
		],
		"stateMutability": "nonpayable",
		"type": "constructor"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "owner",
				"type": "address"
			}
		],
		"name": "OwnableInvalidOwner",
		"type": "error"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "account",
				"type": "address"
			}
		],
		"name": "OwnableUnauthorizedAccount",
		"type": "error"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": false,
				"internalType": "bool",
				"name": "enabled",
				"type": "bool"
			}
		],
		"name": "AutoTradingToggled",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "token",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "amount",
				"type": "uint256"
			}
		],
		"name": "BudgetApproved",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "token",
				"type": "address"
			}
		],
		"name": "BudgetRevoked",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "previousOwner",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "address",
				"name": "newOwner",
				"type": "address"
			}
		],
		"name": "OwnershipTransferred",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": false,
				"internalType": "address",
				"name": "account",
				"type": "address"
			}
		],
		"name": "Paused",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "priceFeedIn",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "address",
				"name": "priceFeedOut",
				"type": "address"
			}
		],
		"name": "PriceFeedsUpdated",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "tokenIn",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "amountIn",
				"type": "uint256"
			},
			{
				"indexed": true,
				"internalType": "address",
				"name": "tokenOut",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "amountOut",
				"type": "uint256"
			},
			{
				"indexed": false,
				"internalType": "int256",
				"name": "usdProfit",
				"type": "int256"
			}
		],
		"name": "Swapped",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "tokenIn",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "address",
				"name": "tokenOut",
				"type": "address"
			}
		],
		"name": "TokensUpdated",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "token",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "amount",
				"type": "uint256"
			}
		],
		"name": "ToppedUp",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": false,
				"internalType": "address",
				"name": "account",
				"type": "address"
			}
		],
		"name": "Unpaused",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "token",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "amount",
				"type": "uint256"
			}
		],
		"name": "Withdrawn",
		"type": "event"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "amount",
				"type": "uint256"
			}
		],
		"name": "approveNativeBudget",
		"outputs": [],
		"stateMutability": "payable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "token",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "amount",
				"type": "uint256"
			}
		],
		"name": "approveTokenBudget",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "amountIn",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "amountOutMin",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "minUSDValueOut",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "deadline",
				"type": "uint256"
			}
		],
		"name": "autoNativeSwap",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "amountIn",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "amountOutMin",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "minUSDValueOut",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "deadline",
				"type": "uint256"
			}
		],
		"name": "autoTokenSwap",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"name": "autoTradeBudget",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "autoTradingEnabled",
		"outputs": [
			{
				"internalType": "bool",
				"name": "",
				"type": "bool"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "getBalance",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "nativeBalance",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "amountIn",
				"type": "uint256"
			}
		],
		"name": "getExpectedOutput",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "priceFeed",
				"type": "address"
			}
		],
		"name": "getUSDPrice",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "amount",
				"type": "uint256"
			},
			{
				"internalType": "address",
				"name": "priceFeed",
				"type": "address"
			}
		],
		"name": "getUSDValue",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "amountIn",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "amountOutMin",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "minUSDValueOut",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "deadline",
				"type": "uint256"
			}
		],
		"name": "manualNativeSwap",
		"outputs": [],
		"stateMutability": "payable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "amountIn",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "amountOutMin",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "minUSDValueOut",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "deadline",
				"type": "uint256"
			}
		],
		"name": "manualTokenSwap",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "owner",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "pause",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "paused",
		"outputs": [
			{
				"internalType": "bool",
				"name": "",
				"type": "bool"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "priceFeedIn",
		"outputs": [
			{
				"internalType": "contract AggregatorV3Interface",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "priceFeedOut",
		"outputs": [
			{
				"internalType": "contract AggregatorV3Interface",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "renounceOwnership",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "token",
				"type": "address"
			}
		],
		"name": "revokeBudget",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "router",
		"outputs": [
			{
				"internalType": "contract IUniswapV2Router",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "_priceFeedIn",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "_priceFeedOut",
				"type": "address"
			}
		],
		"name": "setPriceFeeds",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "_tokenIn",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "_tokenOut",
				"type": "address"
			}
		],
		"name": "setTokens",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "bool",
				"name": "enable",
				"type": "bool"
			}
		],
		"name": "toggleAutoTrading",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "tokenIn",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "tokenOut",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "topUpNative",
		"outputs": [],
		"stateMutability": "payable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "token",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "amount",
				"type": "uint256"
			}
		],
		"name": "topUpToken",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "newOwner",
				"type": "address"
			}
		],
		"name": "transferOwnership",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "unpause",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "token",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "amount",
				"type": "uint256"
			}
		],
		"name": "withdraw",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "wrappedNative",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"stateMutability": "payable",
		"type": "receive"
	}
];

    const ERC20_ABI = [
      "function balanceOf(address) view returns (uint256)",
      "function approve(address spender, uint256 amount) external returns (bool)",
      "function transferFrom(address sender, address recipient, uint256 amount) external returns (bool)",
      "function decimals() view returns (uint8)",
      "function symbol() view returns (string)"
    ];

    // Utility Functions
    async function getTokenDecimals(tokenAddress) {
      if (tokenAddress === NATIVE_ADDRESS) return 18;
      try {
        const tokenContract = new web3.eth.Contract(ERC20_ABI, tokenAddress);
        const decimals = await tokenContract.methods.decimals().call();
        return Number(decimals);
      } catch (error) {
        logMessage(`Failed to fetch decimals for ${tokenAddress}: ${error.message}`);
        return 0;
      }
    }

    async function getTokenSymbol(tokenAddress) {
      if (tokenAddress === NATIVE_ADDRESS) return 'MATIC';
      const token = TOKENS.find(t => t.address === tokenAddress);
      if (token) return token.symbol;
      try {
        const tokenContract = new web3.eth.Contract(ERC20_ABI, tokenAddress);
        return await tokenContract.methods.symbol().call();
      } catch (error) {
        return 'Unknown';
      }
    }

    async function getBlockTimestamp(blockNumber) {
      const block = await web3.eth.getBlock(blockNumber);
      return new Date(block.timestamp * 1000).toLocaleString();
    }

    function handleError(error, action) {
      let message = 'An error occurred';
      if (error.message.includes('reverted')) message = 'Transaction failed. Please check your inputs.';
      else if (error.message.includes('denied')) message = 'Transaction denied by user.';
      else if (error.message.includes('insufficient')) message = 'Insufficient funds.';
      else message = error.message;
      logMessage(`${action} failed: ${message}`);
    }

    // Initialization
    function initializeTokenDropdowns() {
      const selects = ['tokenIn', 'tokenOut', 'budgetToken'];
      selects.forEach(id => {
        const select = document.getElementById(id);
        select.innerHTML = '<option value="" disabled selected>Select Token</option>';
        TOKENS.forEach(token => {
          select.insertAdjacentHTML('beforeend', `<option value="${token.address}">${token.symbol}</option>`);
        });
        select.insertAdjacentHTML('beforeend', `<option value="${NATIVE_ADDRESS}">MATIC</option>`);
      });
    }

    function initializePriceFeedDropdowns() {
      const selects = ['priceFeedIn', 'priceFeedOut'];
      selects.forEach(id => {
        const select = document.getElementById(id);
        select.innerHTML = '<option value="" disabled selected>Select Price Feed</option>';
        PRICE_FEEDS.forEach(feed => {
          select.insertAdjacentHTML('beforeend', `<option value="${feed.address}">${feed.name}</option>`);
        });
      });
    }

    async function addCustomToken(type) {
      const inputId = `customToken${type}`;
      const address = document.getElementById(inputId).value;
      if (!ADDRESS_REGEX.test(address)) {
        logMessage("Invalid token address");
        return;
      }
      const decimals = await getTokenDecimals(address);
      const symbol = await getTokenSymbol(address);
      TOKENS.push({ name: symbol, address, decimals, coingeckoId: '', symbol });
      const selectId = `token${type}`;
      const select = document.getElementById(selectId);
      select.insertAdjacentHTML('beforeend', `<option value="${address}">${symbol}</option>`);
      select.value = address;
      document.getElementById(inputId).value = '';
      updateTokenDropdowns();
      ['budgetToken'].forEach(id => {
        document.getElementById(id).insertAdjacentHTML('beforeend', `<option value="${address}">${symbol}</option>`);
      });
      logMessage(`Added custom token: ${symbol} (${address})`);
    }

    async function addCustomPriceFeed(type) {
      const inputId = `customPriceFeed${type}`;
      const address = document.getElementById(inputId).value;
      if (!ADDRESS_REGEX.test(address)) {
        logMessage("Invalid price feed address");
        return;
      }
      const name = 'Custom Feed';
      PRICE_FEEDS.push({ name, address, asset: name });
      const selectId = `priceFeed${type}`;
      const select = document.getElementById(selectId);
      select.insertAdjacentHTML('beforeend', `<option value="${address}">${name}</option>`);
      select.value = address;
      document.getElementById(inputId).value = '';
      logMessage(`Added custom price feed: ${address}`);
    }

    // Wallet Connection
    async function connectWallet() {
      if (!window.ethereum) {
        logMessage("MetaMask not detected");
        return;
      }
      try {
        await window.ethereum.request({ method: 'eth_requestAccounts' });
        web3.setProvider(window.ethereum);
        account = (await web3.eth.getAccounts())[0];
        contract = new web3.eth.Contract(CONTRACT_ABI, CONTRACT_ADDRESS);
        document.getElementById("walletStatus").innerText = `Wallet: ${account}`;
        logMessage(`Connected wallet: ${account}`);
        document.getElementById('connectButton').style.display = 'none';
        document.getElementById('disconnectButton').style.display = 'block';
        initializeTokenDropdowns();
        initializePriceFeedDropdowns();
        updatePrices();
        updateBudgetStatus();
        updateNativeBalance();
        updatePnL();
        updateContractStatus();
        fetchPastEvents();
        contract.events.allEvents({}, (error, event) => error ? logMessage(`Event error: ${error.message}`) : processEvent(event));
        setInterval(updatePnL, 10 * 60 * 1000);
        setInterval(updateNativeBalance, 30 * 1000);
      } catch (error) {
        handleError(error, 'Wallet Connection');
      }
    }

    function disconnectWallet() {
      account = null;
      contract = null;
      web3.setProvider('https://polygon-rpc.com/');
      document.getElementById('walletStatus').innerText = 'Wallet: Not Connected';
      document.getElementById('nativeBalance').innerText = 'Native Balance: 0 MATIC';
      logMessage('Wallet disconnected');
      document.getElementById('connectButton').style.display = 'block';
      document.getElementById('disconnectButton').style.display = 'none';
    }

    // Contract Interactions
    async function setTokens() {
      if (!contract) return logMessage("Please connect wallet first");
      try {
        const tokenInVal = document.getElementById("tokenIn").value;
        const tokenOutVal = document.getElementById("tokenOut").value;
        if (!tokenInVal || !tokenOutVal) {
          logMessage("Please select both Token In and Token Out");
          return;
        }
        if (!ADDRESS_REGEX.test(tokenInVal) || !ADDRESS_REGEX.test(tokenOutVal)) {
          throw new Error("Invalid token address");
        }
        const tx = await contract.methods.setTokens(tokenInVal, tokenOutVal).send({ from: account });
        tokenIn = tokenInVal;
        tokenOut = tokenOutVal;
        tokenInDecimals = await getTokenDecimals(tokenIn);
        tokenOutDecimals = await getTokenDecimals(tokenOut);
        logMessage(`Tokens set: ${await getTokenSymbol(tokenIn)} -> ${await getTokenSymbol(tokenOut)} - Tx: <a href="${POLYGONSCAN_URL}${tx.transactionHash}" target="_blank">${tx.transactionHash}</a>`);
        updateTokenDropdowns();
      } catch (error) {
        handleError(error, 'Set Tokens');
      }
    }

    async function setPriceFeeds() {
      if (!contract) return logMessage("Please connect wallet first");
      try {
        const priceFeedInVal = document.getElementById("priceFeedIn").value;
        const priceFeedOutVal = document.getElementById("priceFeedOut").value;
        if (!priceFeedInVal || !priceFeedOutVal) {
          logMessage("Please select both Price Feed In and Price Feed Out");
          return;
        }
        if (!ADDRESS_REGEX.test(priceFeedInVal) || !ADDRESS_REGEX.test(priceFeedOutVal)) {
          throw new Error("Invalid price feed address");
        }
        const tx = await contract.methods.setPriceFeeds(priceFeedInVal, priceFeedOutVal).send({ from: account });
        priceFeedIn = priceFeedInVal;
        priceFeedOut = priceFeedOutVal;
        logMessage(`Price feeds set: ${priceFeedIn}, ${priceFeedOut} - Tx: <a href="${POLYGONSCAN_URL}${tx.transactionHash}" target="_blank">${tx.transactionHash}</a>`);
        updatePrices();
      } catch (error) {
        handleError(error, 'Set Price Feeds');
      }
    }

    async function updatePrices() {
      if (!contract || !tokenIn || !tokenOut || !priceFeedIn || !priceFeedOut) return;
      try {
        const tokenInSymbol = await getTokenSymbol(tokenIn);
        const tokenOutSymbol = await getTokenSymbol(tokenOut);
        const amountIn = (1 * (10 ** tokenInDecimals)).toString();
        const amountOut = (1 * (10 ** tokenOutDecimals)).toString();
        const usdValueIn = web3.utils.fromWei(await contract.methods.getUSDValue(amountIn, priceFeedIn).call(), 'ether');
        const usdValueOut = web3.utils.fromWei(await contract.methods.getUSDValue(amountOut, priceFeedOut).call(), 'ether');
        const priceIn = usdValueIn > 0 ? `$${usdValueIn}` : 'Price not available';
        const priceOut = usdValueOut > 0 ? `$${usdValueOut}` : 'Price not available';
        document.getElementById("priceStatus").innerText = `Prices: 1 ${tokenInSymbol} = ${priceIn}, 1 ${tokenOutSymbol} = ${priceOut}`;
      } catch (error) {
        document.getElementById("priceStatus").innerText = `Prices: Error fetching prices`;
        handleError(error, 'Update Prices');
      }
    }

    async function updateTokenDropdowns() {
      if (!account || !contract) return;
      const tokenInSelect = document.getElementById("tokenIn");
      const tokenOutSelect = document.getElementById("tokenOut");
      const tokenInValue = tokenInSelect.value;
      const tokenOutValue = tokenOutSelect.value;

      Array.from(tokenInSelect.options).forEach(option => {
        option.disabled = option.value === tokenOutValue && option.value !== "";
      });
      Array.from(tokenOutSelect.options).forEach(option => {
        option.disabled = option.value === tokenInValue && option.value !== "";
      });

      if (tokenInValue) {
        const balance = await getContractBalance(tokenInValue);
        const usdValue = await getCoinGeckoPrice(TOKENS.find(t => t.address === tokenInValue)?.coingeckoId || 'matic-network') * balance;
        document.getElementById("tokenInInfo").innerText = `Balance: ${balance.toFixed(4)} | Value: $${usdValue.toFixed(2)}`;
        const symbolIn = await getTokenSymbol(tokenInValue);
        document.getElementById("chartTokenInLabel").innerText = `Chart for ${symbolIn}`;
        document.getElementById("chartTokenIn").innerHTML = getChartHtml(tokenInValue);
      } else {
        document.getElementById("chartTokenInLabel").innerText = "Select Token In to view Chart";
        document.getElementById("chartTokenIn").innerHTML = "";
      }

      if (tokenOutValue) {
        const balance = await getContractBalance(tokenOutValue);
        const usdValue = await getCoinGeckoPrice(TOKENS.find(t => t.address === tokenOutValue)?.coingeckoId || 'matic-network') * balance;
        document.getElementById("tokenOutInfo").innerText = `Balance: ${balance.toFixed(4)} | Value: $${usdValue.toFixed(2)}`;
        const symbolOut = await getTokenSymbol(tokenOutValue);
        document.getElementById("chartTokenOutLabel").innerText = `Chart for ${symbolOut}`;
        document.getElementById("chartTokenOut").innerHTML = getChartHtml(tokenOutValue);
      } else {
        document.getElementById("chartTokenOutLabel").innerText = "Select Token Out to view Chart";
        document.getElementById("chartTokenOut").innerHTML = "";
     явиї

      if (tokenInValue && tokenOutValue) {
        const symbolIn = await getTokenSymbol(tokenInValue);
        const symbolOut = await getTokenSymbol(tokenOutValue);
        document.getElementById("currentPair").innerText = `Current Pair: ${symbolIn}/${symbolOut}`;
      } else {
        document.getElementById("currentPair").innerText = "Current Pair: Not Set";
      }
    }

    async function getContractBalance(tokenAddress) {
      if (!contract) return 0;
      try {
        if (tokenAddress === NATIVE_ADDRESS) {
          const balance = await contract.methods.getBalance().call();
          return parseFloat(web3.utils.fromWei(balance, 'ether'));
        } else {
          const tokenContract = new web3.eth.Contract(ERC20_ABI, tokenAddress);
          const decimals = await getTokenDecimals(tokenAddress);
          const balance = await tokenContract.methods.balanceOf(CONTRACT_ADDRESS).call();
          return parseFloat(balance) / (10 ** decimals);
        }
      } catch (error) {
        handleError(error, 'Get Contract Balance');
        return 0;
      }
    }

    async function fetchPastEvents() {
      if (!contract) return;
      const events = await contract.getPastEvents('allEvents', { fromBlock: 0, toBlock: 'latest' });
      for (const event of events) {
        await processEvent(event);
      }
    }

    async function processEvent(event) {
      const timestamp = await getBlockTimestamp(event.blockNumber);
      const eventName = event.event;
      let details = '';
      switch (eventName) {
        case 'Swapped':
          const tokenInSymbol = await getTokenSymbol(event.returnValues.tokenIn);
          const tokenOutSymbol = await getTokenSymbol(event.returnValues.tokenOut);
          const amountIn = web3.utils.fromWei(event.returnValues.amountIn, 'ether');
          const amountOut = web3.utils.fromWei(event.returnValues.amountOut, 'ether');
          const profit = web3.utils.fromWei(event.returnValues.usdProfit, 'ether');
          details = `Swapped ${amountIn} ${tokenInSymbol} for ${amountOut} ${tokenOutSymbol}, profit: $${profit}`;
          break;
        case 'ToppedUp':
          const topUpTokenSymbol = await getTokenSymbol(event.returnValues.token);
          const topUpAmount = web3.utils.fromWei(event.returnValues.amount, 'ether');
          details = `Topped up ${topUpAmount} ${topUpTokenSymbol}`;
          break;
        default:
          details = JSON.stringify(event.returnValues);
      }
      const txHash = event.transactionHash;
      const row = `<tr><td>${timestamp}</td><td>${eventName}</td><td>${details}</td><td><a href="${POLYGONSCAN_URL}${txHash}" target="_blank">${txHash}</a></td></tr>`;
      document.getElementById("transactionLog").getElementsByTagName("tbody")[0].insertAdjacentHTML('afterbegin', row);
    }

    function getChartHtml(tokenAddress) {
      if (tokenAddress === NATIVE_ADDRESS) {
        return `<iframe src="https://www.coingecko.com/en/coins/matic-network/usd#panel" width="100%" height="500" frameborder="0"></iframe>`;
      }
      const token = TOKENS.find(t => t.address === tokenAddress);
      if (!token || !token.coingeckoId) {
        return '<p>Chart not available for this token.</p>';
      }
      const url = `https://www.coingecko.com/en/coins/${token.coingeckoId}/usd#panel`;
      return `<iframe src="${url}" width="100%" height="500" frameborder="0"></iframe>`;
    }

    function refreshCharts() {
      const tokenInValue = document.getElementById("tokenIn").value;
      const tokenOutValue = document.getElementById("tokenOut").value;
      document.getElementById("chartTokenIn").innerHTML = getChartHtml(tokenInValue);
      document.getElementById("chartTokenOut").innerHTML = getChartHtml(tokenOutValue);
    }

    function toggleCharts() {
      const charts = document.getElementById("marketCharts");
      if (charts.style.display === "none") {
        charts.style.display = "block";
        document.querySelector("#marketCharts button:nth-of-type(2)").innerText = "Hide Charts";
      } else {
        charts.style.display = "none";
        document.querySelector("#marketCharts button:nth-of-type(2)").innerText = "Show Charts";
      }
    }

    async function approveBudget() {
      if (!contract) return logMessage("Please connect wallet first");
      try {
        const token = document.getElementById("budgetToken").value;
        if (!token) {
          logMessage("Please select a budget token");
          return;
        }
        const amount = parseFloat(document.getElementById("budgetAmount").value);
        if (isNaN(amount) || amount <= 0) {
          logMessage("Please enter a valid amount greater than zero");
          return;
        }
        const decimals = await getTokenDecimals(token);
        const amountWei = (amount * (10 ** decimals)).toString();
        let tx;
        if (token === NATIVE_ADDRESS) {
          tx = await contract.methods.approveNativeBudget(amountWei).send({ from: account, value: amountWei });
        } else {
          tx = await contract.methods.approveTokenBudget(token, amountWei).send({ from: account });
        }
        logMessage(`Budget approved - Tx: <a href="${POLYGONSCAN_URL}${tx.transactionHash}" target="_blank">${tx.transactionHash}</a>`);
        updateBudgetStatus();
        updateNativeBalance();
      } catch (error) {
        handleError(error, 'Approve Budget');
      }
    }

    async function revokeBudget() {
      if (!contract) return logMessage("Please connect wallet first");
      try {
        const token = document.getElementById("budgetToken").value;
        if (!token) {
          logMessage("Please select a budget token");
          return;
        }
        const tx = await contract.methods.revokeBudget(token).send({ from: account });
        logMessage(`Budget revoked - Tx: <a href="${POLYGONSCAN_URL}${tx.transactionHash}" target="_blank">${tx.transactionHash}</a>`);
        updateBudgetStatus();
        updateNativeBalance();
      } catch (error) {
        handleError(error, 'Revoke Budget');
      }
    }

    async function getCoinGeckoPrice(coingeckoId) {
      if (!coingeckoId) return 0;
      try {
        const response = await fetch(`https://api.coingecko.com/api/v3/simple/price?ids=${coingeckoId}&vs_currencies=usd`);
        const data = await response.json();
        return data[coingeckoId].usd;
      } catch (error) {
        logMessage(`CoinGecko price fetch failed: ${error.message}`);
        return 0;
      }
    }

    // Other functions (unchanged or minimally modified)
    async function updateNativeBalance() {
      if (!contract) return;
      try {
        const balance = await contract.methods.getBalance().call();
        document.getElementById("nativeBalance").innerText = `Native Balance: ${parseFloat(web3.utils.fromWei(balance, 'ether')).toFixed(4)} MATIC`;
      } catch (error) {
        handleError(error, 'Update Native Balance');
      }
    }

    function logMessage(message) {
      console.log(`${new Date().toLocaleTimeString()} - ${message}`);
    }

    function toggleSidebar() {
      document.getElementById('sidebar').classList.toggle('hidden');
    }

    document.addEventListener("DOMContentLoaded", () => {
      initializeTokenDropdowns();
      initializePriceFeedDropdowns();
      if (window.ethereum) {
        window.ethereum.on('accountsChanged', () => location.reload());
        window.ethereum.on('chainChanged', () => location.reload());
      }
    });

    // Placeholder for remaining functions (unchanged)
    function setTradingParameters() { /* unchanged */ }
    function setTechnicalParameters() { /* unchanged */ }
    function setMinSignals() { /* unchanged */ }
    async function manualSell() { /* similar to manualBuy with validation */ }
    async function toggleAutoTrading() { /* unchanged with validation */ }
    async function autoTrade(direction) { /* unchanged */ }
    async function topUpContract() { /* unchanged with validation */ }
    async function withdrawFunds() { /* unchanged with validation */ }
    async function updatePnL() { /* unchanged */ }
    async function fetchMarketData(token, timeframe) { /* unchanged */ }
    async function updateSignals() { /* unchanged */ }
    function calculateSignals(prices, volumes) { /* unchanged */ }
    async function updateContractStatus() { /* unchanged */ }
    async function pauseContract() { /* unchanged with validation */ }
    async function unpauseContract() { /* unchanged with validation */ }
  </script>
  <script src="https://unpkg.com/web3@1.7.0/dist/web3.min.js"></script>
</body>
</html>