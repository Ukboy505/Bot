<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Advanced Trading Bot for Polygon Network">
  <title>Trading Bot Dashboard</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>
  <script src="https://unpkg.com/web3@1.7.0/dist/web3.min.js"></script>
  <script src="https://unpkg.com/technicalindicators@3.1.0/dist/browser.min.js"></script>
  <style>
    /* Reset and Global Styles */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', sans-serif;
      background-color: #1a1a1a;
      color: #e0e0e0;
      line-height: 1.5;
      font-size: 16px;
    }

    .container {
      display: flex;
      min-height: 100vh;
    }

    /* Sidebar */
    .sidebar {
      width: 280px;
      background-color: #222222;
      padding: 20px;
      transition: transform 0.3s ease;
      border-right: 1px solid #333;
    }

    .sidebar-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    .sidebar-header h1 {
      font-size: 24px;
      font-weight: 600;
    }

    .sidebar-toggle {
      background: none;
      border: none;
      color: #e0e0e0;
      font-size: 24px;
      cursor: pointer;
    }

    .main-toggle {
      background: none;
      border: none;
      color: #e0e0e0;
      font-size: 24px;
      cursor: pointer;
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 1001;
      display: none;
    }

    .sidebar:not(.hidden) + .main-content .main-toggle {
      display: none;
    }

    .sidebar.hidden + .main-content .main-toggle {
      display: block;
    }

    .wallet-section, .contract-status, .timeframe-section {
      margin-bottom: 20px;
    }

    .wallet-section p, .contract-status p, .timeframe-section p {
      font-size: 14px;
      margin-top: 10px;
    }

    .contract-status .btn {
      margin-top: 10px;
    }

    .timeframe-section select {
      width: 100%;
      padding: 8px;
      border-radius: 4px;
      background: #333;
      color: #e0e0e0;
      border: 1px solid #444;
    }

    /* Main Content */
    .main-content {
      flex: 1;
      padding: 20px;
      overflow-y: auto;
      position: relative;
    }

    .sidebar.hidden + .main-content {
      padding-top: 40px;
    }

    .dashboard-header {
      margin-bottom: 20px;
    }

    .dashboard-header h2 {
      font-size: 28px;
      font-weight: 600;
    }

    .dashboard-header p {
      font-size: 14px;
      color: #a0a0a0;
    }

    /* Card */
    .card {
      background: #252525;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 20px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .card h3 {
      font-size: 20px;
      font-weight: 600;
      margin-bottom: 15px;
    }

    /* Form Grid */
    .form-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
    }

    .form-group {
      display: flex;
      flex-direction: column;
    }

    .form-group label {
      font-size: 14px;
      margin-bottom: 5px;
      color: #a0a0a0;
    }

    .form-group input, .form-group select {
      padding: 10px;
      border-radius: 4px;
      border: 1px solid #444;
      background: #333;
      color: #e0e0e0;
      font-size: 14px;
      transition: border-color 0.2s;
    }

    .form-group input:focus, .form-group select:focus {
      outline: none;
      border-color: #007bff;
    }

    .form-group p {
      font-size: 12px;
      color: #a0a0a0;
      margin-top: 5px;
    }

    /* Buttons */
    .btn {
      padding: 10px 20px;
      border: none;
      border-radius: 4px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: background-color 0.2s, transform 0.1s;
    }

    .btn-primary {
      background-color: #007bff;
      color: #fff;
    }

    .btn-primary:hover {
      background-color: #0056b3;
    }

    .btn-secondary {
      background-color: #444;
      color: #e0e0e0;
    }

    .btn-secondary:hover {
      background-color: #555;
    }

    .btn-buy {
      background-color: #28a745;
      color: #fff;
    }

    .btn-buy:hover {
      background-color: #218838;
    }

    .btn-sell {
      background-color: #dc3545;
      color: #fff;
    }

    .btn-sell:hover {
      background-color: #c82333;
    }

    .btn-danger {
      background-color: #dc3545;
      color: #fff;
    }

    .btn-danger:hover {
      background-color: #c82333;
    }

    .btn-success {
      background-color: #28a745;
      color: #fff;
    }

    .btn-success:hover {
      background-color: #218838;
    }

    .btn-toggle {
      background-color: #ffc107;
      color: #000;
    }

    .btn-toggle:hover {
      background-color: #e0a800;
    }

    .action-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }

    .action-buttons p {
      font-size: 14px;
      color: #a0a0a0;
      margin-left: 10px;
    }

    /* Table */
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
    }

    th, td {
      padding: 12px;
      text-align: left;
      font-size: 14px;
    }

    th {
      background: #333;
      color: #e0e0e0;
      font-weight: 600;
    }

    td {
      border-bottom: 1px solid #444;
    }

    tr:hover {
      background: #2a2a2a;
    }

    /* Log Area */
    .log-area {
      max-height: 300px;
      overflow-y: auto;
      background: #333;
      padding: 10px;
      border-radius: 4px;
      font-size: 14px;
      color: #a0a0a0;
    }

    .log-area a {
      color: #007bff;
      text-decoration: none;
    }

    .log-area a:hover {
      text-decoration: underline;
    }

    /* Loading Indicator */
    .loading {
      text-align: center;
      padding: 20px;
      color: #a0a0a0;
    }

    /* Responsive Design */
    @media (max-width: 768px) {
      .container {
        flex-direction: column;
      }

      .sidebar {
        width: 100%;
        position: fixed;
        top: 0;
        left: 0;
        z-index: 1000;
        height: 100%;
        transform: translateX(0);
        transition: transform 0.3s ease;
      }

      .sidebar.hidden {
        transform: translateX(-100%);
      }

      .main-content {
        padding: 10px;
        margin-top: 0;
        overflow: auto;
      }

      .form-grid {
        grid-template-columns: 1fr;
      }
    }

    @media (max-width: 480px) {
      .dashboard-header h2 {
        font-size: 24px;
      }

      .card h3 {
        font-size: 18px;
      }

      .btn {
        padding: 8px 16px;
        font-size: 12px;
      }

      th, td {
        font-size: 12px;
        padding: 8px;
      }
    }

    /* Accessibility */
    :focus {
      outline: 2px solid #007bff;
      outline-offset: 2px;
    }

    [aria-live="polite"] {
      overflow-anchor: none;
    }

    /* Scrollbar */
    ::-webkit-scrollbar {
      width: 8px;
    }

    ::-webkit-scrollbar-track {
      background: #333;
    }

    ::-webkit-scrollbar-thumb {
      background: #555;
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: #666;
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Sidebar (Visible on Load) -->
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <h1>Trading Bot</h1>
        <button class="sidebar-toggle" aria-label="Toggle Sidebar" onclick="toggleSidebar()">☰</button>
      </div>
      <div class="wallet-section">
        <button id="connectButton" class="btn btn-primary" onclick="connectWallet()">Connect Wallet</button>
        <button id="disconnectButton" class="btn btn-secondary" onclick="disconnectWallet()" style="display: none;">Disconnect Wallet</button>
        <p id="walletStatus">Wallet: Not Connected</p>
        <p id="nativeBalance">Native Balance: 0 MATIC</p>
        <p id="pnlStatus">PnL: $0.00 (Since 12:00 AM WAT)</p>
      </div>
      <div class="timeframe-section">
        <label for="timeframe">Timeframe:</label>
        <select id="timeframe" onchange="setTimeframe()">
          <option value="1m">1 Minute</option>
          <option value="5m" selected>5 Minutes</option>
          <option value="15m">15 Minutes</option>
          <option value="1h">1 Hour</option>
        </select>
      </div>
    </aside>

    <!-- Main Content -->
    <main class="main-content">
      <button class="main-toggle" aria-label="Toggle Sidebar" onclick="toggleSidebar()">☰</button>
      <!-- Dashboard Header -->
      <header class="dashboard-header">
        <h2>Dashboard</h2>
        <p id="priceStatus">Prices: Loading...</p>
      </header>

      <!-- Contract Status -->
      <section class="card contract-status">
        <h3>Contract Status</h3>
        <p id="contractStatus">Contract Status: Not Connected</p>
        <div class="action-buttons">
          <button id="pauseButton" class="btn btn-danger" onclick="pauseContract()" style="display: none;">Pause Contract</button>
          <button id="unpauseButton" class="btn btn-success" onclick="unpauseContract()" style="display: none;">Unpause Contract</button>
        </div>
      </section>

      <!-- Current Tokens -->
      <section class="card current-tokens">
        <h3>Current Tokens</h3>
        <p id="currentTokenIn">Token In: Not Set</p>
        <p id="currentTokenOut">Token Out: Not Set</p>
      </section>

      <!-- Token Selection -->
      <section class="card token-selection">
        <h3>Token Pair</h3>
        <div class="form-grid">
          <div class="form-group">
            <label for="tokenIn">Token In:</label>
            <select id="tokenIn" onchange="updateTokenDropdowns()">
              <option value="" disabled selected>Select Token</option>
            </select>
            <input type="text" id="customTokenIn" placeholder="Custom Token Address" aria-label="Custom Token In Address">
            <button onclick="addCustomToken('tokenIn')">Add Custom Token</button>
            <p id="tokenInInfo">Balance: 0.0000 | Value: $0.00</p>
          </div>
          <div class="form-group">
            <label for="tokenOut">Token Out:</label>
            <select id="tokenOut" onchange="updateTokenDropdowns()">
              <option value="" disabled selected>Select Token</option>
            </select>
            <input type="text" id="customTokenOut" placeholder="Custom Token Address" aria-label="Custom Token Out Address">
            <button onclick="addCustomToken('tokenOut')">Add Custom Token</button>
            <p id="tokenOutInfo">Balance: 0.0000 | Value: $0.00</p>
          </div>
        </div>
        <button class="btn btn-secondary" onclick="setTokens()">Set Tokens</button>
      </section>

      <!-- Price Feed Selection -->
      <section class="card price-feed-selection">
        <h3>Price Feeds</h3>
        <div class="form-grid">
          <div class="form-group">
            <label for="priceFeedIn">Price Feed In:</label>
            <select id="priceFeedIn">
              <option value="" disabled selected>Select Price Feed</option>
            </select>
            <input type="text" id="customPriceFeedIn" placeholder="Custom Price Feed Address" aria-label="Custom Price Feed In Address">
            <button onclick="addCustomPriceFeed('priceFeedIn')">Add Custom Price Feed</button>
          </div>
          <div class="form-group">
            <label for="priceFeedOut">Price Feed Out:</label>
            <select id="priceFeedOut">
              <option value="" disabled selected>Select Price Feed</option>
            </select>
            <input type="text" id="customPriceFeedOut" placeholder="Custom Price Feed Address" aria-label="Custom Price Feed Out Address">
            <button onclick="addCustomPriceFeed('priceFeedOut')">Add Custom Price Feed</button>
          </div>
        </div>
        <button class="btn btn-secondary" onclick="setPriceFeeds()">Set Price Feeds</button>
      </section>

      <!-- Charts -->
      <section class="card charts" id="chartsSection" style="display: none;">
        <h3>Market Charts</h3>
        <div id="chartContainer">
          <div id="tokenInChart" style="width: 100%; height: 400px;"></div>
          <div id="tokenOutChart" style="width: 100%; height: 400px;"></div>
        </div>
        <button class="btn btn-secondary" onclick="refreshCharts()">Refresh Charts</button>
        <button class="btn btn-secondary" onclick="toggleCharts()">Hide Charts</button>
      </section>

      <!-- Individual Token Charts -->
      <section class="card token-charts">
        <h3>Individual Token Charts</h3>
        <select id="chartTokenSelect" onchange="displayTokenChart()">
          <option value="" disabled selected>Select Token for Chart</option>
        </select>
        <div id="selectedTokenChart" style="width: 100%; height: 400px;"></div>
      </section>

      <!-- Trading Parameters -->
      <section class="card trading-parameters">
        <h3>Trading Parameters</h3>
        <div class="form-grid">
          <div class="form-group">
            <label for="profitRange">Profit Range (%):</label>
            <input type="number" id="profitRange" value="1" min="0" step="0.1" aria-label="Profit Range Percentage">
          </div>
          <div class="form-group">
            <label for="stopLoss">Stop Loss (%):</label>
            <input type="number" id="stopLoss" value="1" min="0" step="0.1" aria-label="Stop Loss Percentage">
          </div>
          <div class="form-group">
            <label for="slippage">Slippage (%):</label>
            <input type="number" id="slippage" value="1" min="0" step="0.1" aria-label="Slippage Percentage">
          </div>
        </div>
        <button class="btn btn-secondary" onclick="setTradingParameters()">Set Parameters</button>
      </section>

      <!-- Technical Parameters -->
      <section class="card technical-parameters">
        <h3>Technical Analysis Parameters</h3>
        <div class="form-grid">
          <div class="form-group">
            <label for="macdFast">MACD Fast:</label>
            <input type="number" id="macdFast" value="12" min="1" aria-label="MACD Fast Period">
            <button class="btn btn-secondary" onclick="updateTechParam('macdFast')">Update</button>
          </div>
          <div class="form-group">
            <label for="macdSlow">MACD Slow:</label>
            <input type="number" id="macdSlow" value="26" min="1" aria-label="MACD Slow Period">
            <button class="btn btn-secondary" onclick="updateTechParam('macdSlow')">Update</button>
          </div>
          <div class="form-group">
            <label for="macdSignal">MACD Signal:</label>
            <input type="number" id="macdSignal" value="9" min="1" aria-label="MACD Signal Period">
            <button class="btn btn-secondary" onclick="updateTechParam('macdSignal')">Update</button>
          </div>
          <div class="form-group">
            <label for="rsiPeriod">RSI Period:</label>
            <input type="number" id="rsiPeriod" value="14" min="1" aria-label="RSI Period">
            <button class="btn btn-secondary" onclick="updateTechParam('rsiPeriod')">Update</button>
          </div>
          <div class="form-group">
            <label for="minRsi">Min RSI:</label>
            <input type="number" id="minRsi" value="30" min="0" max="100" aria-label="Minimum RSI">
            <button class="btn btn-secondary" onclick="updateTechParam('minRsi')">Update</button>
          </div>
          <div class="form-group">
            <label for="maxRsi">Max RSI:</label>
            <input type="number" id="maxRsi" value="70" min="0" max="100" aria-label="Maximum RSI">
            <button class="btn btn-secondary" onclick="updateTechParam('maxRsi')">Update</button>
          </div>
          <div class="form-group">
            <label for="volumePeriod">Volume Period:</label>
            <input type="number" id="volumePeriod" value="14" min="1" aria-label="Volume Period">
            <button class="btn btn-secondary" onclick="updateTechParam('volumePeriod')">Update</button>
          </div>
          <div class="form-group">
            <label for="minVolumeSpike">Min Volume Spike:</label>
            <input type="number" id="minVolumeSpike" value="1.5" min="0" step="0.1" aria-label="Minimum Volume Spike">
            <button class="btn btn-secondary" onclick="updateTechParam('minVolumeSpike')">Update</button>
          </div>
          <div class="form-group">
            <label for="maxVolumeSpike">Max Volume Spike:</label>
            <input type="number" id="maxVolumeSpike" value="3.0" min="0" step="0.1" aria-label="Maximum Volume Spike">
            <button class="btn btn-secondary" onclick="updateTechParam('maxVolumeSpike')">Update</button>
          </div>
          <div class="form-group">
            <label for="emaPeriod">EMA Period:</label>
            <input type="number" id="emaPeriod" value="20" min="1" aria-label="EMA Period">
            <button class="btn btn-secondary" onclick="updateTechParam('emaPeriod')">Update</button>
          </div>
          <div class="form-group">
            <label for="bollingerPeriod">Bollinger Period:</label>
            <input type="number" id="bollingerPeriod" value="20" min="1" aria-label="Bollinger Period">
            <button class="btn btn-secondary" onclick="updateTechParam('bollingerPeriod')">Update</button>
          </div>
          <div class="form-group">
            <label for="bollingerStdDev">Bollinger Std Dev:</label>
            <input type="number" id="bollingerStdDev" value="2" min="0" step="0.1" aria-label="Bollinger Standard Deviation">
            <button class="btn btn-secondary" onclick="updateTechParam('bollingerStdDev')">Update</button>
          </div>
          <div class="form-group">
            <label for="minSignals">Minimum Signals:</label>
            <input type="number" id="minSignals" value="2" min="1" max="7" aria-label="Minimum Signals">
            <button class="btn btn-secondary" onclick="updateTechParam('minSignals')">Update</button>
          </div>
        </div>
      </section>

      <!-- Trading Actions -->
      <section class="card trading-actions">
        <h3>Trading Actions</h3>
        <div class="action-buttons">
          <div class="form-group">
            <label for="buyAmount">Buy Amount:</label>
            <input type="number" id="buyAmount" value="1" min="0" step="0.01" aria-label="Buy Amount in Tokens">
          </div>
          <button class="btn btn-buy" onclick="manualBuy()">Buy</button>
          <p id="buyResult">Result: None</p>
          <div class="form-group">
            <label for="sellAmount">Sell Amount:</label>
            <input type="number" id="sellAmount" value="1" min="0" step="0.01" aria-label="Sell Amount in Tokens">
          </div>
          <button class="btn btn-sell" onclick="manualSell()">Sell</button>
          <p id="sellResult">Result: None</p>
          <button class="btn btn-toggle" onclick="toggleAutoTrading()">Toggle Auto-Trading (Off)</button>
          <p id="autoTradingStatus">Auto-Trading: Off</p>
        </div>
      </section>

      <!-- Signals Table -->
      <section class="card signals-table">
        <h3>Market Signals</h3>
        <table id="tokenSignals">
          <thead>
            <tr>
              <th>Token</th>
              <th>Signals</th>
              <th>RSI</th>
              <th>MACD</th>
              <th>Indicators & Patterns</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
        <p id="analysisResult">Market Analysis: Loading...</p>
      </section>

      <!-- Wallet Balances -->
      <section class="card wallet-balances">
        <h3>Wallet Balances</h3>
        <table id="walletBalances">
          <thead>
            <tr>
              <th>Token</th>
              <th>Balance</th>
              <th>USD Value</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </section>

      <!-- Funding Actions -->
      <section class="card funding-actions">
        <h3>Funding</h3>
        <div class="form-grid">
          <div class="form-group">
            <label for="topUpToken">Top-Up Token:</label>
            <select id="topUpToken"></select>
            <label for="topUpAmount">Amount:</label>
            <input type="number" id="topUpAmount" value="0" min="0" step="0.01" aria-label="Top-Up Amount">
            <p id="topUpValue">Value: $0.00</p>
            <button class="btn btn-secondary" onclick="topUpContract()">Top Up</button>
            <p id="topUpResult">Result: None</p>
          </div>
          <div class="form-group">
            <label for="budgetToken">Budget Token:</label>
            <select id="budgetToken"></select>
            <label for="budgetAmount">Amount:</label>
            <input type="number" id="budgetAmount" value="0" min="0" step="0.01" aria-label="Budget Amount">
            <button class="btn btn-secondary" onclick="setBudgetToOnePercent()">Set to 1%</button>
            <p id="budgetValue">Value: $0.00</p>
            <button class="btn btn-secondary" onclick="approveBudget()">Approve Budget</button>
            <button class="btn btn-danger" onclick="revokeBudget()">Revoke Budget</button>
            <p id="budgetStatus">Budget: 0 MATIC</p>
          </div>
          <div class="form-group">
            <label for="withdrawToken">Withdraw Token:</label>
            <select id="withdrawToken"></select>
            <label for="withdrawAmount">Amount:</label>
            <input type="number" id="withdrawAmount" value="0" min="0" step="0.01" aria-label="Withdraw Amount">
            <p id="withdrawValue">Value: $0.00</p>
            <button class="btn btn-secondary" onclick="withdrawFunds()">Withdraw</button>
            <p id="withdrawResult">Result: None</p>
          </div>
        </div>
      </section>

      <!-- Log Area -->
      <section class="card log-area">
        <h3>Transaction Logs</h3>
        <table id="logTable">
          <thead>
            <tr>
              <th>Timestamp</th>
              <th>Event</th>
              <th>Details</th>
              <th>Tx Hash</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </section>
    </main>
  </div>

  <script type="text/javascript">
    const CONTRACT_ADDRESS = '0x56672b9dde9d6d10cd5dd10fc8579a425c24ac02';
    const QUICKSWAP_ROUTER = '0xa5E0829CaCEd8fFDD4De3c43696c57F7D7A678ff';
    const NATIVE_ADDRESS = '0x0000000000000000000000000000000000000000';
    const POLYGONSCAN_URL = 'https://polygonscan.com/tx/';

    const PUBLIC_RPC_URL = 'https://polygon-rpc.com';
    const publicWeb3 = new Web3(new Web3.providers.HttpProvider(PUBLIC_RPC_URL));

    const TOKENS = [
      { name: 'USDT', address: '0xc2132D05D31c914a87C6611C10748AEb04B58e8F', decimals: 6, coingeckoId: 'tether', priceFeed: '0x0A6513e40db6EB1b165753AD52E80663aeA50545' },
      { name: 'USDC', address: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174', decimals: 6, coingeckoId: 'usd-coin', priceFeed: '0xfE4A8cc5b5B2366C1B58Bea3858e81843581b2F7' },
      { name: 'DAI', address: '0x8f3Cf7ad23Cd3CaDbD9735AFf958023239c6A063', decimals: 18, coingeckoId: 'dai', priceFeed: '0x4746DeC9e833A82EC7C2C1356372CcF2cfcD2F3D' },
      { name: 'POL', address: '0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270', decimals: 18, coingeckoId: 'matic-network', priceFeed: '0xAB594600376Ec9fD91F8e885dADF0CE036862dE0' },
      { name: 'ADA', address: '0xE6a991fF0bf2C1a599c7057b7865b03aC15bF4B2', decimals: 18, coingeckoId: 'cardano', priceFeed: '0x882554df528115a743c4537828DA8D5B58e52544' },
      { name: 'MKR', address: '0x6f7C932e7684666C9fd1d44527765433e01fF61d', decimals: 18, coingeckoId: 'maker', priceFeed: '0xa070427bF5bA5709f70e98b94Cb2F435a242C46C' },
      { name: 'WETH', address: '0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619', decimals: 18, coingeckoId: 'weth', priceFeed: '0xF9680D99D6C9589e2a93a78A04A279e509205945' },
      { name: 'WBTC', address: '0x1BFD67037B42Cf73acF2047067bd4F2C47D9BfD6', decimals: 8, coingeckoId: 'wrapped-bitcoin', priceFeed: '0xDE31F8bFBD8c84b5360CFACCa3539B938dd78ae6' }
    ];

    let priceFeedsList = [
      { name: 'USDT / USD', address: '0x0A6513e40db6EB1b165753AD52E80663aeA50545' },
      { name: 'USDC / USD', address: '0xfE4A8cc5b5B2366C1B58Bea3858e81843581b2F7' },
      { name: 'DAI / USD', address: '0x4746DeC9e833A82EC7C2C1356372CcF2cfcD2F3D' },
      { name: 'MATIC / USD', address: '0xAB594600376Ec9fD91F8e885dADF0CE036862dE0' },
      { name: 'ADA / USD', address: '0x882554df528115a743c4537828DA8D5B58e52544' },
      { name: 'MKR / USD', address: '0xa070427bF5bA5709f70e98b94Cb2F435a242C46C' },
      { name: 'ETH / USD', address: '0xF9680D99D6C9589e2a93a78A04A279e509205945' },
      { name: 'WBTC / USD', address: '0xDE31F8bFBD8c84b5360CFACCa3539B938dd78ae6' }
    ];

    let web3, account, contract;
    let autoTradingActive = false;
    let autoTradingInterval;
    let tokenIn, tokenOut, priceFeedIn, priceFeedOut, tokenInDecimals, tokenOutDecimals;
    let timeframe = '5m';
    let tradingParams = { profitRange: 1, stopLoss: 1, slippage: 1 };
    let techParams = {
      macdFast: 12,
      macdSlow: 26,
      macdSignal: 9,
      rsiPeriod: 14,
      minRsi: 30,
      maxRsi: 70,
      volumePeriod: 14,
      minVolumeSpike: 1.5,
      maxVolumeSpike: 3.0,
      emaPeriod: 20,
      bollingerPeriod: 20,
      bollingerStdDev: 2,
      minSignals: 2
    };
    let dailyPnL = 0;

    const CONTRACT_ABI = [
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "_router",
            "type": "address"
          },
          {
            "internalType": "address",
            "name": "_wrappedNative",
            "type": "address"
          }
        ],
        "stateMutability": "nonpayable",
        "type": "constructor"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "owner",
            "type": "address"
          }
        ],
        "name": "OwnableInvalidOwner",
        "type": "error"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "account",
            "type": "address"
          }
        ],
        "name": "OwnableUnauthorizedAccount",
        "type": "error"
      },
      {
        "anonymous": false,
        "inputs": [
          {
            "indexed": false,
            "internalType": "bool",
            "name": "enabled",
            "type": "bool"
          }
        ],
        "name": "AutoTradingToggled",
        "type": "event"
      },
      {
        "anonymous": false,
        "inputs": [
          {
            "indexed": true,
            "internalType": "address",
            "name": "token",
            "type": "address"
          },
          {
            "indexed": false,
            "internalType": "uint256",
            "name": "amount",
            "type": "uint256"
          }
        ],
        "name": "BudgetApproved",
        "type": "event"
      },
      {
        "anonymous": false,
        "inputs": [
          {
            "indexed": true,
            "internalType": "address",
            "name": "token",
            "type": "address"
          }
        ],
        "name": "BudgetRevoked",
        "type": "event"
      },
      {
        "anonymous": false,
        "inputs": [
          {
            "indexed": true,
            "internalType": "address",
            "name": "previousOwner",
            "type": "address"
          },
          {
            "indexed": true,
            "internalType": "address",
            "name": "newOwner",
            "type": "address"
          }
        ],
        "name": "OwnershipTransferred",
        "type": "event"
      },
      {
        "anonymous": false,
        "inputs": [
          {
            "indexed": false,
            "internalType": "address",
            "name": "account",
            "type": "address"
          }
        ],
        "name": "Paused",
        "type": "event"
      },
      {
        "anonymous": false,
        "inputs": [
          {
            "indexed": true,
            "internalType": "address",
            "name": "priceFeedIn",
            "type": "address"
          },
          {
            "indexed": true,
            "internalType": "address",
            "name": "priceFeedOut",
            "type": "address"
          }
        ],
        "name": "PriceFeedsUpdated",
        "type": "event"
      },
      {
        "anonymous": false,
        "inputs": [
          {
            "indexed": true,
            "internalType": "address",
            "name": "tokenIn",
            "type": "address"
          },
          {
            "indexed": false,
            "internalType": "uint256",
            "name": "amountIn",
            "type": "uint256"
          },
          {
            "indexed": true,
            "internalType": "address",
            "name": "tokenOut",
            "type": "address"
          },
          {
            "indexed": false,
            "internalType": "uint256",
            "name": "amountOut",
            "type": "uint256"
          },
          {
            "indexed": false,
            "internalType": "int256",
            "name": "usdProfit",
            "type": "int256"
          }
        ],
        "name": "Swapped",
        "type": "event"
      },
      {
        "anonymous": false,
        "inputs": [
          {
            "indexed": true,
            "internalType": "address",
            "name": "tokenIn",
            "type": "address"
          },
          {
            "indexed": true,
            "internalType": "address",
            "name": "tokenOut",
            "type": "address"
          }
        ],
        "name": "TokensUpdated",
        "type": "event"
      },
      {
        "anonymous": false,
        "inputs": [
          {
            "indexed": true,
            "internalType": "address",
            "name": "token",
            "type": "address"
          },
          {
            "indexed": false,
            "internalType": "uint256",
            "name": "amount",
            "type": "uint256"
          }
        ],
        "name": "ToppedUp",
        "type": "event"
      },
      {
        "anonymous": false,
        "inputs": [
          {
            "indexed": false,
            "internalType": "address",
            "name": "account",
            "type": "address"
          }
        ],
        "name": "Unpaused",
        "type": "event"
      },
      {
        "anonymous": false,
        "inputs": [
          {
            "indexed": true,
            "internalType": "address",
            "name": "token",
            "type": "address"
          },
          {
            "indexed": false,
            "internalType": "uint256",
            "name": "amount",
            "type": "uint256"
          }
        ],
        "name": "Withdrawn",
        "type": "event"
      },
      {
        "inputs": [
          {
            "internalType": "uint256",
            "name": "amount",
            "type": "uint256"
          }
        ],
        "name": "approveNativeBudget",
        "outputs": [],
        "stateMutability": "payable",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "token",
            "type": "address"
          },
          {
            "internalType": "uint256",
            "name": "amount",
            "type": "uint256"
          }
        ],
        "name": "approveTokenBudget",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "uint256",
            "name": "amountIn",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "amountOutMin",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "minUSDValueOut",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "deadline",
            "type": "uint256"
          }
        ],
        "name": "autoNativeSwap",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "uint256",
            "name": "amountIn",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "amountOutMin",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "minUSDValueOut",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "deadline",
            "type": "uint256"
          }
        ],
        "name": "autoTokenSwap",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "",
            "type": "address"
          }
        ],
        "name": "autoTradeBudget",
        "outputs": [
          {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "autoTradingEnabled",
        "outputs": [
          {
            "internalType": "bool",
            "name": "",
            "type": "bool"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "getBalance",
        "outputs": [
          {
            "internalType": "uint256",
            "name": "nativeBalance",
            "type": "uint256"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "uint256",
            "name": "amountIn",
            "type": "uint256"
          }
        ],
        "name": "getExpectedOutput",
        "outputs": [
          {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "priceFeed",
            "type": "address"
          }
        ],
        "name": "getUSDPrice",
        "outputs": [
          {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "uint256",
            "name": "amount",
            "type": "uint256"
          },
          {
            "internalType": "address",
            "name": "priceFeed",
            "type": "address"
          }
        ],
        "name": "getUSDValue",
        "outputs": [
          {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "uint256",
            "name": "amountIn",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "amountOutMin",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "minUSDValueOut",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "deadline",
            "type": "uint256"
          }
        ],
        "name": "manualNativeSwap",
        "outputs": [],
        "stateMutability": "payable",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "uint256",
            "name": "amountIn",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "amountOutMin",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "minUSDValueOut",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "deadline",
            "type": "uint256"
          }
        ],
        "name": "manualTokenSwap",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "owner",
        "outputs": [
          {
            "internalType": "address",
            "name": "",
            "type": "address"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "pause",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "paused",
        "outputs": [
          {
            "internalType": "bool",
            "name": "",
            "type": "bool"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "priceFeedIn",
        "outputs": [
          {
            "internalType": "contract AggregatorV3Interface",
            "name": "",
            "type": "address"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "priceFeedOut",
        "outputs": [
          {
            "internalType": "contract AggregatorV3Interface",
            "name": "",
            "type": "address"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "renounceOwnership",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "token",
            "type": "address"
          }
        ],
        "name": "revokeBudget",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "router",
        "outputs": [
          {
            "internalType": "contract IUniswapV2Router",
            "name": "",
            "type": "address"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "_priceFeedIn",
            "type": "address"
          },
          {
            "internalType": "address",
            "name": "_priceFeedOut",
            "type": "address"
          }
        ],
        "name": "setPriceFeeds",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "_tokenIn",
            "type": "address"
          },
          {
            "internalType": "address",
            "name": "_tokenOut",
            "type": "address"
          }
        ],
        "name": "setTokens",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "bool",
            "name": "enable",
            "type": "bool"
          }
        ],
        "name": "toggleAutoTrading",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "tokenIn",
        "outputs": [
          {
            "internalType": "address",
            "name": "",
            "type": "address"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "tokenOut",
        "outputs": [
          {
            "internalType": "address",
            "name": "",
            "type": "address"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "topUpNative",
        "outputs": [],
        "stateMutability": "payable",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "token",
            "type": "address"
          },
          {
            "internalType": "uint256",
            "name": "amount",
            "type": "uint256"
          }
        ],
        "name": "topUpToken",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "newOwner",
            "type": "address"
          }
        ],
        "name": "transferOwnership",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "unpause",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "token",
            "type": "address"
          },
          {
            "internalType": "uint256",
            "name": "amount",
            "type": "uint256"
          }
        ],
        "name": "withdraw",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "wrappedNative",
        "outputs": [
          {
            "internalType": "address",
            "name": "",
            "type": "address"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "stateMutability": "payable",
        "type": "receive"
      }
    ];

    const ERC20_ABI = [
      "function balanceOf(address) view returns (uint256)",
      "function approve(address spender, uint256 amount) external returns (bool)",
      "function transferFrom(address sender, address recipient, uint256 amount) external returns (bool)",
      "function decimals() view returns (uint8)",
      "function symbol() view returns (string)"
    ];

    const ADDRESS_REGEX = /^0x[0-9a-fA-F]{40}$/;

    document.addEventListener("DOMContentLoaded", () => {
      initializeDropdowns();
      if (window.ethereum) {
        window.ethereum.on('accountsChanged', () => location.reload());
        window.ethereum.on('chainChanged', () => location.reload());
      }
    });

    function initializeDropdowns() {
      const tokenSelects = ['tokenIn', 'tokenOut', 'budgetToken', 'topUpToken', 'withdrawToken'];
      tokenSelects.forEach(selectId => {
        const select = document.getElementById(selectId);
        select.innerHTML = '<option value="" disabled selected>Select Token</option>';
        TOKENS.forEach(token => {
          const option = document.createElement('option');
          option.value = token.address;
          option.text = token.name;
          select.add(option);
        });
        const nativeOption = document.createElement('option');
        nativeOption.value = NATIVE_ADDRESS;
        nativeOption.text = 'MATIC';
        select.add(nativeOption);
      });

      const priceFeedSelects = ['priceFeedIn', 'priceFeedOut'];
      priceFeedSelects.forEach(selectId => {
        const select = document.getElementById(selectId);
        select.innerHTML = '<option value="" disabled selected>Select Price Feed</option>';
        priceFeedsList.forEach(feed => {
          const option = document.createElement('option');
          option.value = feed.address;
          option.text = feed.name;
          select.add(option);
        });
      });

      const chartTokenSelect = document.getElementById('chartTokenSelect');
      TOKENS.forEach(token => {
        const option = document.createElement('option');
        option.value = token.coingeckoId;
        option.text = token.name;
        chartTokenSelect.add(option);
      });
    }

    async function addCustomToken(type) {
      const inputId = type === 'tokenIn' ? 'customTokenIn' : 'customTokenOut';
      const address = document.getElementById(inputId).value.trim();
      if (!ADDRESS_REGEX.test(address)) {
        logMessage('Invalid token address format');
        return;
      }
      try {
        const tokenContract = new publicWeb3.eth.Contract(ERC20_ABI, address);
        const decimals = await tokenContract.methods.decimals().call();
        const symbol = await tokenContract.methods.symbol().call();
        const newToken = { name: symbol, address, decimals: Number(decimals), coingeckoId: null, priceFeed: null };
        TOKENS.push(newToken);
        updateTokenDropdowns();
        document.getElementById(inputId).value = '';
        logMessage(`Added custom token: ${symbol} (${address})`);
      } catch (error) {
        logMessage('Failed to add custom token. Please check the address.');
      }
    }

    async function addCustomPriceFeed(type) {
      const inputId = type === 'priceFeedIn' ? 'customPriceFeedIn' : 'customPriceFeedOut';
      const address = document.getElementById(inputId).value.trim();
      if (!ADDRESS_REGEX.test(address)) {
        logMessage('Invalid price feed address format');
        return;
      }
      const newFeed = { name: `Custom Feed (${address.slice(0, 6)}...)`, address };
      priceFeedsList.push(newFeed);
      updatePriceFeedDropdowns();
      document.getElementById(inputId).value = '';
      logMessage(`Added custom price feed: ${address}`);
    }

    function updateTokenDropdowns() {
      const tokenSelects = ['tokenIn', 'tokenOut', 'budgetToken', 'topUpToken', 'withdrawToken'];
      tokenSelects.forEach(selectId => {
        const select = document.getElementById(selectId);
        while (select.options.length > 1) {
          select.remove(1);
        }
        TOKENS.forEach(token => {
          const option = document.createElement('option');
          option.value = token.address;
          option.text = token.name;
          select.add(option);
        });
        const nativeOption = document.createElement('option');
        nativeOption.value = NATIVE_ADDRESS;
        nativeOption.text = 'MATIC';
        select.add(nativeOption);
      });
      if (contract) {
        updateTokenInfo();
      }
    }

    function updatePriceFeedDropdowns() {
      const priceFeedSelects = ['priceFeedIn', 'priceFeedOut'];
      priceFeedSelects.forEach(selectId => {
        const select = document.getElementById(selectId);
        while (select.options.length > 1) {
          select.remove(1);
        }
        priceFeedsList.forEach(feed => {
          const option = document.createElement('option');
          option.value = feed.address;
          option.text = feed.name;
          select.add(option);
        });
      });
    }

    async function getTokenDecimals(tokenAddress, usePublic = false) {
      if (tokenAddress === NATIVE_ADDRESS) return 18;
      try {
        const web3Instance = usePublic ? publicWeb3 : web3;
        if (!web3Instance) throw new Error('Web3 not initialized');
        const tokenContract = new web3Instance.eth.Contract(ERC20_ABI, tokenAddress);
        const decimals = await tokenContract.methods.decimals().call();
        return Number(decimals);
      } catch (error) {
        logMessage(`Failed to fetch decimals for ${tokenAddress}. Assuming 18 decimals.`);
        return 18;
      }
    }

    async function updateTokenInfo() {
      if (!contract) return;
      const tokenInValue = document.getElementById("tokenIn").value;
      const tokenOutValue = document.getElementById("tokenOut").value;

      if (tokenInValue) {
        const token = TOKENS.find(t => t.address === tokenInValue) || { name: 'MATIC', decimals: 18, coingeckoId: 'matic-network' };
        tokenInDecimals = await getTokenDecimals(tokenInValue);
        const balance = await getContractBalance(tokenInValue);
        const usdValue = await getCoinGeckoPrice(token.coingeckoId) * balance;
        document.getElementById("tokenInInfo").innerText = `Balance: ${balance.toFixed(4)} | Value: $${usdValue.toFixed(2)}`;
        if (balance === 0) logMessage(`${token.name} has no balance in contract`);
      }
      if (tokenOutValue) {
        const token = TOKENS.find(t => t.address === tokenOutValue) || { name: 'MATIC', decimals: 18, coingeckoId: 'matic-network' };
        tokenOutDecimals = await getTokenDecimals(tokenOutValue);
        const balance = await getContractBalance(tokenOutValue);
        const usdValue = await getCoinGeckoPrice(token.coingeckoId) * balance;
        document.getElementById("tokenOutInfo").innerText = `Balance: ${balance.toFixed(4)} | Value: $${usdValue.toFixed(2)}`;
        if (balance === 0) logMessage(`${token.name} has no balance in contract`);
      }
    }

    async function updateCurrentTokens() {
      if (!contract) return;
      try {
        const tokenInAddr = await contract.methods.tokenIn().call();
        const tokenOutAddr = await contract.methods.tokenOut().call();
        let tokenInSymbol = 'Not Set';
        let tokenOutSymbol = 'Not Set';

        if (tokenInAddr !== NATIVE_ADDRESS && ADDRESS_REGEX.test(tokenInAddr)) {
          const tokenContract = new web3.eth.Contract(ERC20_ABI, tokenInAddr);
          tokenInSymbol = await tokenContract.methods.symbol().call();
        } else if (tokenInAddr === NATIVE_ADDRESS) {
          tokenInSymbol = 'MATIC';
        }
        if (tokenOutAddr !== NATIVE_ADDRESS && ADDRESS_REGEX.test(tokenOutAddr)) {
          const tokenContract = new web3.eth.Contract(ERC20_ABI, tokenOutAddr);
          tokenOutSymbol = await tokenContract.methods.symbol().call();
        } else if (tokenOutAddr === NATIVE_ADDRESS) {
          tokenOutSymbol = 'MATIC';
        }

        document.getElementById("currentTokenIn").innerText = `Token In: ${tokenInSymbol} (${tokenInAddr})`;
        document.getElementById("currentTokenOut").innerText = `Token Out: ${tokenOutSymbol} (${tokenOutAddr})`;
      } catch (error) {
        logMessage('Failed to fetch current tokens. Please check contract connection.');
      }
    }

    async function setTokens() {
      if (!contract) {
        logMessage('Please connect wallet first');
        return;
      }
      const tokenInVal = document.getElementById("tokenIn").value;
      const tokenOutVal = document.getElementById("tokenOut").value;

      if (!tokenInVal || !tokenOutVal) {
        logMessage('Please select both Token In and Token Out');
        return;
      }
      if (tokenInVal === tokenOutVal) {
        logMessage('Token In and Token Out cannot be the same');
        return;
      }
      if (!ADDRESS_REGEX.test(tokenInVal) || !ADDRESS_REGEX.test(tokenOutVal)) {
        logMessage('Invalid token address format');
        return;
      }

      try {
        tokenIn = tokenInVal;
        tokenOut = tokenOutVal;
        tokenInDecimals = await getTokenDecimals(tokenIn);
        tokenOutDecimals = await getTokenDecimals(tokenOut);
        const tx = await contract.methods.setTokens(tokenIn, tokenOut).send({ from: account });
        logMessage(`Tokens set successfully - Tx: <a href="${POLYGONSCAN_URL}${tx.transactionHash}" target="_blank">${tx.transactionHash}</a>`);
        await updateCurrentTokens();
        updateCharts();
        updatePrices();
        updateTransactionLog();
      } catch (error) {
        logMessage('Failed to set tokens. Please try again.');
      }
    }

    async function setPriceFeeds() {
      if (!contract) {
        logMessage('Please connect wallet first');
        return;
      }
      const priceFeedInVal = document.getElementById("priceFeedIn").value;
      const priceFeedOutVal = document.getElementById("priceFeedOut").value;

      if (!priceFeedInVal || !priceFeedOutVal) {
        logMessage('Please select both Price Feed In and Price Feed Out');
        return;
      }
      if (!ADDRESS_REGEX.test(priceFeedInVal) || !ADDRESS_REGEX.test(priceFeedOutVal)) {
        logMessage('Invalid price feed address format');
        return;
      }

      try {
        priceFeedIn = priceFeedInVal;
        priceFeedOut = priceFeedOutVal;
        const tx = await contract.methods.setPriceFeeds(priceFeedIn, priceFeedOut).send({ from: account });
        logMessage(`Price feeds set successfully - Tx: <a href="${POLYGONSCAN_URL}${tx.transactionHash}" target="_blank">${tx.transactionHash}</a>`);
        updatePrices();
        updateTransactionLog();
      } catch (error) {
        logMessage('Failed to set price feeds. Please try again.');
      }
    }

    async function fetchHistoricalData(tokenId) {
      if (!tokenId) return [];
      try {
        const response = await fetch(
          `https://api.coingecko.com/api/v3/coins/${tokenId}/market_chart?vs_currency=usd&days=30&interval=daily`
        );
        const data = await response.json();
        return data.prices.map((price) => ({
          time: price[0] / 1000,
          value: price[1],
        }));
      } catch (error) {
        logMessage(`Failed to fetch historical data for ${tokenId}`);
        return [];
      }
    }

    async function generateChart(tokenId, chartElementId) {
      const chartElement = document.getElementById(chartElementId);
      if (!chartElement) return;

      chartElement.innerHTML = '<div class="loading">Loading chart...</div>';

      const data = await fetchHistoricalData(tokenId);
      if (!data || data.length === 0) {
        chartElement.innerText = 'No data available';
        return;
      }

      const chart = LightweightCharts.createChart(chartElement, {
        width: chartElement.clientWidth,
        height: 400,
        layout: {
          backgroundColor: '#1a1a1a',
          textColor: '#e0e0e0',
        },
        grid: {
          vertLines: { color: '#333' },
          horzLines: { color: '#333' },
        },
        priceScale: { borderColor: '#333' },
        timeScale: { borderColor: '#333' },
      });

      const lineSeries = chart.addLineSeries();
      lineSeries.setData(data);

      chartElement.querySelector('.loading')?.remove();
    }

    function updateCharts() {
      const tokenInId = TOKENS.find((t) => t.address === tokenIn)?.coingeckoId;
      const tokenOutId = TOKENS.find((t) => t.address === tokenOut)?.coingeckoId;

      if (tokenInId) {
        generateChart(tokenInId, 'tokenInChart');
      } else {
        document.getElementById('tokenInChart').innerText = 'No chart available';
      }

      if (tokenOutId) {
        generateChart(tokenOutId, 'tokenOutChart');
      } else {
        document.getElementById('tokenOutChart').innerText = 'No chart available';
      }
    }

    function refreshCharts() {
      updateCharts();
    }

    function toggleCharts() {
      const chartsSection = document.getElementById('chartsSection');
      const toggleButton = document.querySelector("#chartsSection button[onclick='toggleCharts()']");
      if (chartsSection.style.display === 'none') {
        chartsSection.style.display = 'block';
        toggleButton.innerText = 'Hide Charts';
        updateCharts();
      } else {
        chartsSection.style.display = 'none';
        toggleButton.innerText = 'Show Charts';
      }
    }

    function displayTokenChart() {
      const tokenId = document.getElementById('chartTokenSelect').value;
      if (tokenId) {
        generateChart(tokenId, 'selectedTokenChart');
      }
    }

    async function connectWallet() {
      if (!window.ethereum) {
        logMessage("MetaMask not detected. Please install MetaMask.");
        return;
      }

      let localWeb3;
      try {
        localWeb3 = new Web3(window.ethereum);
      } catch (initError) {
        logMessage(`Failed to initialize Web3: ${initError.message}`);
        return;
      }

      try {
        const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
        account = accounts[0];

        const chainId = await window.ethereum.request({ method: 'eth_chainId' });
        if (parseInt(chainId, 16) !== 137) {
          try {
            await window.ethereum.request({
              method: 'wallet_switchEthereumChain',
              params: [{ chainId: '0x89' }],
            });
          } catch (switchError) {
            logMessage("Please switch to the Polygon network in MetaMask.");
            return;
          }
        }

        web3 = localWeb3;
        contract = new web3.eth.Contract(CONTRACT_ABI, CONTRACT_ADDRESS);

        document.getElementById("walletStatus").innerText = `Wallet: ${account}`;
        logMessage(`Connected wallet: ${account}`);
        document.getElementById('connectButton').style.display = 'none';
        document.getElementById('disconnectButton').style.display = 'block';

        updateTokenInfo();
        updateCurrentTokens();
        updatePrices();
        updateBudgetStatus();
        updateWalletBalances();
        updateWithdrawDropdown();
        updateNativeBalance();
        updatePnL();
        updateContractStatus();
        updateTransactionLog();

        window.pnlInterval = setInterval(updatePnL, 10 * 60 * 1000);
        window.balanceInterval = setInterval(updateNativeBalance, 30 * 1000);
      } catch (error) {
        if (error.code === 4001) {
          logMessage("Wallet connection rejected by user.");
        } else if (error.code === -32002) {
          logMessage("Wallet connection request already pending in MetaMask.");
        } else {
          logMessage(`Failed to connect wallet: ${error.message}`);
        }
      }
    }

    function disconnectWallet() {
      account = null;
      contract = null;
      web3 = null;
      tokenIn = null;
      tokenOut = null;
      priceFeedIn = null;
      priceFeedOut = null;
      autoTradingActive = false;
      clearInterval(autoTradingInterval);
      clearInterval(window.pnlInterval);
      clearInterval(window.balanceInterval);

      document.getElementById('walletStatus').innerText = 'Wallet: Not Connected';
      document.getElementById('nativeBalance').innerText = 'Native Balance: 0 MATIC';
      document.getElementById('pnlStatus').innerText = 'PnL: $0.00 (Since 12:00 AM WAT)';
      document.getElementById('contractStatus').innerText = 'Contract Status: Not Connected';
      document.getElementById('pauseButton').style.display = 'none';
      document.getElementById('unpauseButton').style.display = 'none';
      document.getElementById('currentTokenIn').innerText = 'Token In: Not Set';
      document.getElementById('currentTokenOut').innerText = 'Token Out: Not Set';
      document.getElementById('tokenInInfo').innerText = 'Balance: 0.0000 | Value: $0.00';
      document.getElementById('tokenOutInfo').innerText = 'Balance: 0.0000 | Value: $0.00';
      document.getElementById('priceStatus').innerText = 'Prices: Loading...';
      document.getElementById('autoTradingStatus').innerText = 'Auto-Trading: Off';
      document.getElementById('toggleAutoTrading').innerText = 'Toggle Auto-Trading (Off)';
      document.getElementById('buyResult').innerText = 'Result: None';
      document.getElementById('sellResult').innerText = 'Result: None';
      document.getElementById('topUpResult').innerText = 'Result: None';
      document.getElementById('withdrawResult').innerText = 'Result: None';
      document.getElementById('budgetStatus').innerText = 'Budget: 0 MATIC';
      document.getElementById('analysisResult').innerText = 'Market Analysis: Loading...';

      document.getElementById('walletBalances').getElementsByTagName('tbody')[0].innerHTML = '';
      document.getElementById('tokenSignals').getElementsByTagName('tbody')[0].innerHTML = '';
      document.getElementById('logTable').getElementsByTagName('tbody')[0].innerHTML = '';

      const withdrawSelect = document.getElementById('withdrawToken');
      withdrawSelect.innerHTML = '<option value="" disabled selected>Select Token</option>';

      document.getElementById('connectButton').style.display = 'block';
      document.getElementById('disconnectButton').style.display = 'none';

      logMessage('Wallet disconnected');
    }

    async function isContractPaused() {
      if (!contract) return false;
      try {
        return await contract.methods.paused().call();
      } catch (error) {
        logMessage('Error checking contract status. Please try again.');
        return false;
      }
    }

    async function updateContractStatus() {
      if (!contract) {
        document.getElementById("contractStatus").innerText = "Contract Status: Not Connected";
        document.getElementById("pauseButton").style.display = "none";
        document.getElementById("unpauseButton").style.display = "none";
        return;
      }
      try {
        const isPaused = await isContractPaused();
        document.getElementById("contractStatus").innerText = `Contract Status: ${isPaused ? 'Paused' : 'Active'}`;
        document.getElementById("pauseButton").style.display = isPaused ? 'none' : 'block';
        document.getElementById("unpauseButton").style.display = isPaused ? 'block' : 'none';
      } catch (error) {
        document.getElementById("contractStatus").innerText = "Contract Status: Error Fetching Status";
        document.getElementById("pauseButton").style.display = "none";
        document.getElementById("unpauseButton").style.display = "none";
        logMessage('Failed to fetch contract status.');
      }
    }

    async function pauseContract() {
      if (!contract) {
        logMessage("Please connect wallet first");
        return;
      }
      try {
        const tx = await contract.methods.pause().send({ from: account });
        logMessage(`Contract paused - Tx: <a href="${POLYGONSCAN_URL}${tx.transactionHash}" target="_blank">${tx.transactionHash}</a>`);
        await updateContractStatus();
        updateTransactionLog();
      } catch (error) {
        logMessage('Failed to pause contract. Please try again.');
      }
    }

    async function unpauseContract() {
      if (!contract) {
        logMessage("Please connect wallet first");
        return;
      }
      try {
        const tx = await contract.methods.unpause().send({ from: account });
        logMessage(`Contract unpaused - Tx: <a href="${POLYGONSCAN_URL}${tx.transactionHash}" target="_blank">${tx.transactionHash}</a>`);
        await updateContractStatus();
        updateTransactionLog();
      } catch (error) {
        logMessage('Failed to unpause contract. Please try again.');
      }
    }

    function setTimeframe() {
      timeframe = document.getElementById("timeframe").value;
      logMessage(`Timeframe set to ${timeframe}`);
      updateSignals();
    }

    function setTradingParameters() {
      const profitRange = parseFloat(document.getElementById("profitRange").value);
      const stopLoss = parseFloat(document.getElementById("stopLoss").value);
      const slippage = parseFloat(document.getElementById("slippage").value);

      if (isNaN(profitRange) || profitRange < 0 || isNaN(stopLoss) || stopLoss < 0 || isNaN(slippage) || slippage < 0) {
        logMessage('Invalid trading parameters. Please enter positive numbers.');
        return;
      }

      tradingParams.profitRange = profitRange;
      tradingParams.stopLoss = stopLoss;
      tradingParams.slippage = slippage;
      logMessage(`Trading parameters set - Profit: ${tradingParams.profitRange}%, Stop Loss: ${tradingParams.stopLoss}%, Slippage: ${tradingParams.slippage}%`);
    }

    function updateTechParam(paramName) {
      const input = document.getElementById(paramName);
      let value = input.value.trim();
      let parsedValue;

      const integerParams = [
        'macdFast', 'macdSlow', 'macdSignal', 'rsiPeriod', 'volumePeriod',
        'emaPeriod', 'bollingerPeriod', 'minSignals'
      ];
      const isInteger = integerParams.includes(paramName);
      parsedValue = isInteger ? parseInt(value) : parseFloat(value);

      if (isNaN(parsedValue) || parsedValue <= 0) {
        logMessage(`${paramName} must be a positive number.`);
        return;
      }

      if (paramName === 'minRsi' || paramName === 'maxRsi') {
        if (parsedValue < 0 || parsedValue > 100) {
          logMessage(`${paramName} must be between 0 and 100.`);
          return;
        }
        const minRsi = parseFloat(document.getElementById('minRsi').value);
        const maxRsi = parseFloat(document.getElementById('maxRsi').value);
        if (paramName === 'minRsi' && parsedValue >= maxRsi) {
          logMessage('Min RSI must be less than Max RSI.');
          return;
        }
        if (paramName === 'maxRsi' && parsedValue <= minRsi) {
          logMessage('Max RSI must be greater than Min RSI.');
          return;
        }
      }

      if (paramName === 'minSignals' && (parsedValue < 1 || parsedValue > 7)) {
        logMessage('Minimum Signals must be between 1 and 7.');
        return;
      }

      techParams[paramName] = parsedValue;
      logMessage(`${paramName} updated to ${parsedValue}`);
      updateSignals();
    }

    async function getCoinGeckoPrice(coingeckoId) {
      if (!coingeckoId) return 0;
      try {
        const response = await fetch(`https://api.coingecko.com/api/v3/simple/price?ids=${coingeckoId}&vs_currencies=usd`);
        const data = await response.json();
        return data[coingeckoId]?.usd || 0;
      } catch (error) {
        logMessage('Failed to fetch price from CoinGecko.');
        return 0;
      }
    }

    async function updatePrices() {
      if (!contract || !tokenIn || !tokenOut || !priceFeedIn || !priceFeedOut) return;
      try {
        const amountIn = (1 * (10 ** tokenInDecimals)).toString();
        const amountOut = (1 * (10 ** tokenOutDecimals)).toString();
        const usdValueIn = web3.utils.fromWei(await contract.methods.getUSDValue(amountIn, priceFeedIn).call(), 'ether');
        const usdValueOut = web3.utils.fromWei(await contract.methods.getUSDValue(amountOut, priceFeedOut).call(), 'ether');
        const tokenInName = TOKENS.find(t => t.address === tokenIn)?.name || 'MATIC';
        const tokenOutName = TOKENS.find(t => t.address === tokenOut)?.name || 'MATIC';
        document.getElementById("priceStatus").innerText = `Prices: 1 ${tokenInName} = $${usdValueIn}, 1 ${tokenOutName} = $${usdValueOut}`;
      } catch (error) {
        document.getElementById("priceStatus").innerText = 'Prices: Error fetching prices';
        logMessage('Failed to update prices. Ensure tokens and feeds are set.');
      }
    }

    async function getContractBalance(tokenAddress) {
      if (!contract) return 0;
      try {
        if (tokenAddress === NATIVE_ADDRESS) {
          const balance = await contract.methods.getBalance().call();
          return parseFloat(web3.utils.fromWei(balance, 'ether'));
        } else {
          const tokenContract = new web3.eth.Contract(ERC20_ABI, tokenAddress);
          const decimals = await getTokenDecimals(tokenAddress);
          const balance = await tokenContract.methods.balanceOf(CONTRACT_ADDRESS).call();
          return parseFloat(balance) / (10 ** decimals);
        }
      } catch (error) {
        logMessage('Failed to fetch contract balance.');
        return 0;
      }
    }

    async function updateWalletBalances() {
      if (!account || !web3) return;
      const tbody = document.getElementById("walletBalances").getElementsByTagName("tbody")[0];
      tbody.innerHTML = "";
      for (const token of TOKENS.concat([{ name: 'MATIC', address: NATIVE_ADDRESS, decimals: 18, coingeckoId: 'matic-network' }])) {
        const decimals = await getTokenDecimals(token.address);
        let balance;
        if (token.address === NATIVE_ADDRESS) {
          balance = await web3.eth.getBalance(account);
          balance = parseFloat(web3.utils.fromWei(balance, 'ether'));
        } else {
          const tokenContract = new web3.eth.Contract(ERC20_ABI, token.address);
          balance = await tokenContract.methods.balanceOf(account).call();
          balance = parseFloat(balance) / (10 ** decimals);
        }
        const usdValue = await getCoinGeckoPrice(token.coingeckoId) * balance;
        if (balance > 0) {
          tbody.insertAdjacentHTML('beforeend', `<tr><td>${token.name}</td><td>${balance.toFixed(4)}</td><td>$${usdValue.toFixed(2)}</td></tr>`);
        }
      }
    }

    async function updateWithdrawDropdown() {
      if (!contract) return;
      const withdrawSelect = document.getElementById("withdrawToken");
      withdrawSelect.innerHTML = '<option value="" disabled selected>Select Token</option>';
      for (const token of TOKENS.concat([{ name: 'MATIC', address: NATIVE_ADDRESS, decimals: 18, coingeckoId: 'matic-network' }])) {
        const decimals = await getTokenDecimals(token.address);
        const balance = await getContractBalance(token.address);
        const usdValue = await getCoinGeckoPrice(token.coingeckoId) * balance;
        if (balance > 0 && usdValue > 0) {
          withdrawSelect.insertAdjacentHTML('beforeend', `<option value="${token.address}">${token.name} (Bal: ${balance.toFixed(4)}, $${usdValue.toFixed(2)})</option>`);
        }
      }
    }

    async function updateNativeBalance() {
      if (!web3 || !account) {
        document.getElementById('nativeBalance').innerText = 'Native Balance: 0 MATIC';
        return;
      }
      try {
        const balance = await web3.eth.getBalance(account);
        const balanceMATIC = web3.utils.fromWei(balance, 'ether');
        document.getElementById('nativeBalance').innerText = `Native Balance: ${parseFloat(balanceMATIC).toFixed(4)} MATIC`;
      } catch (error) {
        document.getElementById('nativeBalance').innerText = 'Native Balance: 0 MATIC';
        logMessage('Failed to fetch native balance.');
      }
    }

    async function updatePnL() {
      if (!contract || !account) {
        document.getElementById('pnlStatus').innerText = 'PnL: $0.00 (Since 12:00 AM WAT)';
        return;
      }
      try {
        // Simulate PnL based on trades (since getPnL is not implemented in contract)
        document.getElementById('pnlStatus').innerText = `PnL: $${dailyPnL.toFixed(2)} (Since 12:00 AM WAT)`;
      } catch (error) {
        document.getElementById('pnlStatus').innerText = 'PnL: $0.00 (Since 12:00 AM WAT)';
        logMessage('Failed to update PnL.');
      }
    }

    async function fetchMarketData(token, timeframe) {
      // Placeholder: Replace with real API data (e.g., QuickSwap or CoinGecko)
      const prices = Array(50).fill().map(() => Math.random() * 100 + 50);
      const volumes = Array(50).fill().map(() => Math.random() * 1000);
      return { prices, volumes };
    }

    async function updateSignals() {
      if (!tokenIn || !tokenOut || !contract) return;
      const tbody = document.getElementById("tokenSignals").getElementsByTagName("tbody")[0];
      tbody.innerHTML = "";

      const tokens = [tokenIn, tokenOut].map(addr => TOKENS.find(t => t.address === addr) || { name: 'MATIC', coingeckoId: 'matic-network' });
      for (const token of tokens) {
        const { prices, volumes } = await fetchMarketData(token.address, timeframe);
        const signals = calculateSignals(prices, volumes);
        tbody.insertAdjacentHTML('beforeend', `
          <tr>
            <td>${token.name}</td>
            <td>${signals.count}</td>
            <td>${signals.rsi.toFixed(2)}</td>
            <td>${signals.macd.signal > 0 ? 'Bullish' : 'Bearish'}</td>
            <td>${signals.patterns.join(', ')}</td>
          </tr>
        `);
        if (signals.count >= techParams.minSignals && autoTradingActive) {
          logMessage(`Auto-trading triggered for ${token.name} with ${signals.count} signals`);
          await autoTrade(signals.count >= techParams.minSignals ? 'buy' : 'sell');
        }
      }
      document.getElementById("analysisResult").innerText = `Market Analysis: Updated for ${timeframe}`;
    }

    function calculateSignals(prices, volumes) {
      const rsi = technicalindicators.RSI.calculate({ values: prices, period: techParams.rsiPeriod })[0] || 0;
      const macdData = technicalindicators.MACD.calculate({
        values: prices,
        fastPeriod: techParams.macdFast,
        slowPeriod: techParams.macdSlow,
        signalPeriod: techParams.macdSignal
      });
      const macd = macdData[macdData.length - 1] || { MACD: 0, signal: 0 };
      const ema = technicalindicators.EMA.calculate({ values: prices, period: techParams.emaPeriod })[0] || 0;
      const bollinger = technicalindicators.BollingerBands.calculate({
        values: prices,
        period: techParams.bollingerPeriod,
        stdDev: techParams.bollingerStdDev
      })[0] || { upper: 0, middle: 0, lower: 0 };
      const smaVolume = technicalindicators.SMA.calculate({ values: volumes, period: techParams.volumePeriod })[0] || 0;
      const volumeSpike = volumes[volumes.length - 1] / smaVolume;

      let signals = 0;
      const patterns = [];
      if (rsi < techParams.minRsi) { signals++; patterns.push("Oversold RSI"); }
      if (rsi > techParams.maxRsi) { signals++; patterns.push("Overbought RSI"); }
      if (macd.MACD > macd.signal) { signals++; patterns.push("MACD Bullish"); }
      if (macd.MACD < macd.signal) { signals++; patterns.push("MACD Bearish"); }
      if (prices[prices.length - 1] > ema) { signals++; patterns.push("Above EMA"); }
      if (prices[prices.length - 1] > bollinger.upper) { signals++; patterns.push("Above Bollinger Upper"); }
      if (volumeSpike > techParams.minVolumeSpike && volumeSpike < techParams.maxVolumeSpike) { signals++; patterns.push("Volume Spike"); }

      return { count: signals, rsi, macd, patterns };
    }

    async function manualBuy() {
      if (!contract) {
        logMessage("Please connect wallet first");
        return;
      }
      const amount = parseFloat(document.getElementById("buyAmount").value);
      if (isNaN(amount) || amount <= 0) {
        logMessage('Please enter a valid buy amount greater than 0');
        return;
      }
      try {
        const amountIn = (amount * (10 ** tokenInDecimals)).toString();
        const amountOutMin = (amount * (1 - tradingParams.slippage / 100) * (10 ** tokenOutDecimals)).toString();
        const minUSDValueOut = web3.utils.toWei("0.9", 'ether');
        const deadline = Math.floor(Date.now() / 1000) + 60 * 20;

        let txMethod;
        if (tokenIn === NATIVE_ADDRESS) {
          txMethod = contract.methods.manualNativeSwap(amountIn, amountOutMin, minUSDValueOut, deadline);
        } else {
          txMethod = contract.methods.manualTokenSwap(amountIn, amountOutMin, minUSDValueOut, deadline);
        }

        const gasEstimate = await txMethod.estimateGas({
          from: account,
          value: tokenIn === NATIVE_ADDRESS ? amountIn : 0,
        });
        if (gasEstimate > 500000) {
          logMessage('Warning: High gas cost detected (>500k). Consider lowering amount or waiting.');
        }

        const tx = await txMethod.send({
          from: account,
          value: tokenIn === NATIVE_ADDRESS ? amountIn : 0,
        });
        document.getElementById("buyResult").innerText = `Result: Success - Tx: ${tx.transactionHash}`;
        logMessage(`Manual buy successful - Tx: <a href="${POLYGONSCAN_URL}${tx.transactionHash}" target="_blank">${tx.transactionHash}</a>`);
        dailyPnL += 0.1;
        updatePnL();
        updateWalletBalances();
        updateWithdrawDropdown();
        updateNativeBalance();
        updateTransactionLog();
      } catch (error) {
        document.getElementById("buyResult").innerText = 'Result: Failed';
        logMessage('Manual buy failed. Check inputs or contract status.');
      }
    }

    async function manualSell() {
      if (!contract) {
        logMessage("Please connect wallet first");
        return;
      }
      const amount = parseFloat(document.getElementById("sellAmount").value);
      if (isNaN(amount) || amount <= 0) {
        logMessage('Please enter a valid sell amount greater than 0');
        return;
      }
      try {
        const amountIn = (amount * (10 ** tokenOutDecimals)).toString();
        const amountOutMin = (amount * (1 - tradingParams.slippage / 100) * (10 ** tokenInDecimals)).toString();
        const minUSDValueOut = web3.utils.toWei("0.9", 'ether');
        const deadline = Math.floor(Date.now() / 1000) + 60 * 20;

        const tempTokenIn = tokenIn;
        tokenIn = tokenOut;
        tokenOut = tempTokenIn;
        const tempDecimals = tokenInDecimals;
        tokenInDecimals = tokenOutDecimals;
        tokenOutDecimals = tempDecimals;

        let txMethod;
        if (tokenIn === NATIVE_ADDRESS) {
          txMethod = contract.methods.manualNativeSwap(amountIn, amountOutMin, minUSDValueOut, deadline);
        } else {
          txMethod = contract.methods.manualTokenSwap(amountIn, amountOutMin, minUSDValueOut, deadline);
        }

        const gasEstimate = await txMethod.estimateGas({
          from: account,
          value: tokenIn === NATIVE_ADDRESS ? amountIn : 0,
        });
        if (gasEstimate > 500000) {
          logMessage('Warning: High gas cost detected (>500k). Consider lowering amount or waiting.');
        }

        const tx = await txMethod.send({
          from: account,
          value: tokenIn === NATIVE_ADDRESS ? amountIn : 0,
        });
        document.getElementById("sellResult").innerText = `Result: Success - Tx: ${tx.transactionHash}`;
        logMessage(`Manual sell successful - Tx: <a href="${POLYGONSCAN_URL}${tx.transactionHash}" target="_blank">${tx.transactionHash}</a>`);
        dailyPnL -= 0.05;
        updatePnL();
        updateWalletBalances();
        updateWithdrawDropdown();
        updateNativeBalance();
        updateTransactionLog();

        tokenIn = tempTokenIn;
        tokenOut = tempTokenIn;
        tokenInDecimals = tempDecimals;
        tokenOutDecimals = await getTokenDecimals(tokenOut);
      } catch (error) {
        document.getElementById("sellResult").innerText = 'Result: Failed';
        logMessage('Manual sell failed. Check inputs or contract status.');
      }
    }

    async function toggleAutoTrading() {
      if (!contract) {
        logMessage("Please connect wallet first");
        return;
      }
      try {
        autoTradingActive = !autoTradingActive;
        const tx = await contract.methods.toggleAutoTrading(autoTradingActive).send({ from: account });
        document.getElementById("autoTradingStatus").innerText = `Auto-Trading: ${autoTradingActive ? 'On' : 'Off'}`;
        document.getElementById("toggleAutoTrading").innerText = `Toggle Auto-Trading (${autoTradingActive ? 'On' : 'Off'})`;
        logMessage(`Auto-trading ${autoTradingActive ? 'enabled' : 'disabled'} - Tx: <a href="${POLYGONSCAN_URL}${tx.transactionHash}" target="_blank">${tx.transactionHash}</a>`);
        if (autoTradingActive) {
          autoTradingInterval = setInterval(updateSignals, 60 * 1000);
        } else {
          clearInterval(autoTradingInterval);
        }
        updateTransactionLog();
      } catch (error) {
        logMessage('Failed to toggle auto-trading. Please try again.');
        autoTradingActive = !autoTradingActive;
      }
    }

    async function autoTrade(direction) {
      if (!contract) return;
      try {
        const amountIn = (1 * (10 ** tokenInDecimals)).toString();
        const amountOutMin = (1 * (1 - tradingParams.slippage / 100) * (10 ** tokenOutDecimals)).toString();
        const minUSDValueOut = web3.utils.toWei("0.9", 'ether');
        const deadline = Math.floor(Date.now() / 1000) + 60 * 20;

        let tx;
        if (tokenIn === NATIVE_ADDRESS) {
          tx = await contract.methods.autoNativeSwap(amountIn, amountOutMin, minUSDValueOut, deadline).send({ from: account });
        } else {
          tx = await contract.methods.autoTokenSwap(amountIn, amountOutMin, minUSDValueOut, deadline).send({ from: account });
        }
        logMessage(`Auto ${direction} successful - Tx: <a href="${POLYGONSCAN_URL}${tx.transactionHash}" target="_blank">${tx.transactionHash}</a>`);
        dailyPnL += direction === 'buy' ? 0.1 : -0.05;
        updatePnL();
        updateWalletBalances();
        updateWithdrawDropdown();
        updateNativeBalance();
        updateTransactionLog();
      } catch (error) {
        logMessage(`Auto ${direction} failed. Check contract status or budget.`);
      }
    }

    async function topUpContract() {
      if (!contract) {
        logMessage("Please connect wallet first");
        return;
      }
      const token = document.getElementById("topUpToken").value;
      const amount = parseFloat(document.getElementById("topUpAmount").value);
      if (!token || isNaN(amount) || amount <= 0) {
        logMessage('Please select a token and enter a valid amount greater than 0');
        return;
      }
      try {
        const decimals = await getTokenDecimals(token);
        const amountWei = (amount * (10 ** decimals)).toString();
        let tx;
        if (token === NATIVE_ADDRESS) {
          tx = await contract.methods.topUpNative().send({ from: account, value: amountWei });
        } else {
          tx = await contract.methods.topUpToken(token, amountWei).send({ from: account });
        }
        document.getElementById("topUpResult").innerText = `Result: Success - Tx: ${tx.transactionHash}`;
        logMessage(`Top-up successful - Tx: <a href="${POLYGONSCAN_URL}${tx.transactionHash}" target="_blank">${tx.transactionHash}</a>`);
        updateTokenInfo();
        updateWithdrawDropdown();
        updateNativeBalance();
        updateTransactionLog();
      } catch (error) {
        document.getElementById("topUpResult").innerText = 'Result: Failed';
        logMessage('Top-up failed. Check inputs or balance.');
      }
    }

    async function setBudgetToOnePercent() {
      if (!contract) {
        logMessage("Please connect wallet first");
        return;
      }
      const token = document.getElementById("budgetToken").value;
      if (!token) {
        logMessage('Please select a budget token');
        return;
      }
      try {
        let balance;
        if (token === NATIVE_ADDRESS) {
          balance = await web3.eth.getBalance(account);
          balance = parseFloat(web3.utils.fromWei(balance, 'ether'));
        } else {
          const tokenContract = new web3.eth.Contract(ERC20_ABI, token);
          const decimals = await tokenContract.methods.decimals().call();
          balance = await tokenContract.methods.balanceOf(account).call();
          balance = parseFloat(balance) / (10 ** decimals);
        }
        const onePercent = balance * 0.01;
        document.getElementById("budgetAmount").value = onePercent.toFixed(4);
        const usdValue = await getCoinGeckoPrice(TOKENS.find(t => t.address === token)?.coingeckoId || 'matic-network') * onePercent;
        document.getElementById("budgetValue").innerText = `Value: $${usdValue.toFixed(2)}`;
        logMessage(`Budget set to 1% of balance: ${onePercent.toFixed(4)} ${TOKENS.find(t => t.address === token)?.name || 'MATIC'}`);
      } catch (error) {
        logMessage('Failed to set budget to 1%. Check wallet connection.');
      }
    }

    async function approveBudget() {
      if (!contract) {
        logMessage("Please connect wallet first");
        return;
      }
      const token = document.getElementById("budgetToken").value;
      const amount = parseFloat(document.getElementById("budgetAmount").value);
      if (!token || isNaN(amount) || amount <= 0) {
        logMessage('Please select a token and enter a valid amount greater than 0');
        return;
      }
      try {
        let balance;
        if (token === NATIVE_ADDRESS) {
          balance = await web3.eth.getBalance(account);
          balance = parseFloat(web3.utils.fromWei(balance, 'ether'));
        } else {
          const tokenContract = new web3.eth.Contract(ERC20_ABI, token);
          const decimals = await tokenContract.methods.decimals().call();
          balance = await tokenContract.methods.balanceOf(account).call();
          balance = parseFloat(balance) / (10 ** decimals);
        }
        if (amount > balance) {
          logMessage('Budget amount exceeds available balance');
          return;
        }
        const decimals = await getTokenDecimals(token);
        const amountWei = (amount * (10 ** decimals)).toString();
        let tx;
        if (token === NATIVE_ADDRESS) {
          tx = await contract.methods.approveNativeBudget(amountWei).send({ from: account, value: amountWei });
        } else {
          tx = await contract.methods.approveTokenBudget(token, amountWei).send({ from: account });
        }
        logMessage(`Budget approved - Tx: <a href="${POLYGONSCAN_URL}${tx.transactionHash}" target="_blank">${tx.transactionHash}</a>`);
        updateBudgetStatus();
        updateNativeBalance();
        updateTransactionLog();
      } catch (error) {
        logMessage('Budget approval failed. Check inputs or balance.');
      }
    }

    async function revokeBudget() {
      if (!contract) {
        logMessage("Please connect wallet first");
        return;
      }
      const token = document.getElementById("budgetToken").value;
      if (!token) {
        logMessage('Please select a token to revoke budget');
        return;
      }
      try {
        const tx = await contract.methods.revokeBudget(token).send({ from: account });
        logMessage(`Budget revoked - Tx: <a href="${POLYGONSCAN_URL}${tx.transactionHash}" target="_blank">${tx.transactionHash}</a>`);
        updateBudgetStatus();
        updateWithdrawDropdown();
        updateNativeBalance();
        updateTransactionLog();
      } catch (error) {
        logMessage('Budget revocation failed. Please try again.');
      }
    }

    async function updateBudgetStatus() {
      if (!contract) return;
      const token = document.getElementById("budgetToken").value;
      if (!token) return;
      try {
        const decimals = await getTokenDecimals(token);
        const budget = await contract.methods.autoTradeBudget(token).call();
        const tokenName = TOKENS.find(t => t.address === token)?.name || 'MATIC';
        document.getElementById("budgetStatus").innerText = `Budget: ${(parseFloat(budget) / (10 ** decimals)).toFixed(4)} ${tokenName}`;
      } catch (error) {
        logMessage('Failed to update budget status.');
      }
    }

    async function withdrawFunds() {
      if (!contract) {
        logMessage("Please connect wallet first");
        return;
      }
      const token = document.getElementById("withdrawToken").value;
      const amount = parseFloat(document.getElementById("withdrawAmount").value);
      if (!token || isNaN(amount) || amount <= 0) {
        logMessage('Please select a token and enter a valid amount greater than 0');
        return;
      }
      try {
        const decimals = await getTokenDecimals(token);
        const amountWei = (amount * (10 ** decimals)).toString();
        const gasEstimate = await contract.methods.withdraw(token, amountWei).estimateGas({ from: account });
        if (gasEstimate > 500000) {
          logMessage('Warning: High gas cost detected (>500k). Consider lowering amount or waiting.');
        }
        const tx = await contract.methods.withdraw(token, amountWei).send({ from: account });
        document.getElementById("withdrawResult").innerText = `Result: Success - Tx: ${tx.transactionHash}`;
        logMessage(`Withdrawal successful - Tx: <a href="${POLYGONSCAN_URL}${tx.transactionHash}" target="_blank">${tx.transactionHash}</a>`);
        updateTokenInfo();
        updateWithdrawDropdown();
        updateNativeBalance();
        updateTransactionLog();
      } catch (error) {
        document.getElementById("withdrawResult").innerText = 'Result: Failed';
        logMessage('Withdrawal failed. Check inputs or contract balance.');
      }
    }

    async function updateTransactionLog() {
      if (!contract || !account) return;
      const events = [];
      const eventTypes = ['Swapped', 'ToppedUp', 'Withdrawn', 'BudgetApproved', 'BudgetRevoked', 'AutoTradingToggled', 'PriceFeedsUpdated', 'TokensUpdated'];
      try {
        for (const eventType of eventTypes) {
          const pastEvents = await contract.getPastEvents(eventType, { fromBlock: 0, toBlock: 'latest' });
          events.push(...pastEvents.slice(-10)); // Limit to last 10 events for performance
        }
        events.sort((a, b) => b.blockNumber - a.blockNumber || b.transactionIndex - a.transactionIndex);

        const logTableBody = document.getElementById("logTable").getElementsByTagName("tbody")[0];
        logTableBody.innerHTML = '';

        for (const event of events) {
          const block = await web3.eth.getBlock(event.blockNumber);
          const timestamp = new Date(block.timestamp * 1000).toLocaleString();
          const eventName = event.event;
          let details = '';

          switch (eventName) {
            case 'Swapped':
              const tokenInSym = TOKENS.find(t => t.address === event.returnValues.tokenIn)?.name || 'MATIC';
              const tokenOutSym = TOKENS.find(t => t.address === event.returnValues.tokenOut)?.name || 'MATIC';
              const amountIn = (parseFloat(event.returnValues.amountIn) / (10 ** (TOKENS.find(t => t.address === event.returnValues.tokenIn)?.decimals || 18))).toFixed(4);
              const amountOut = (parseFloat(event.returnValues.amountOut) / (10 ** (TOKENS.find(t => t.address === event.returnValues.tokenOut)?.decimals || 18))).toFixed(4);
              details = `Swapped ${amountIn} ${tokenInSym} for ${amountOut} ${tokenOutSym}`;
              break;
            case 'ToppedUp':
              const topUpSym = TOKENS.find(t => t.address === event.returnValues.token)?.name || 'MATIC';
              const topUpAmt = (parseFloat(event.returnValues.amount) / (10 ** (TOKENS.find(t => t.address === event.returnValues.token)?.decimals || 18))).toFixed(4);
              details = `Topped up ${topUpAmt} ${topUpSym}`;
              break;
            case 'Withdrawn':
              const withdrawSym = TOKENS.find(t => t.address === event.returnValues.token)?.name || 'MATIC';
              const withdrawAmt = (parseFloat(event.returnValues.amount) / (10 ** (TOKENS.find(t => t.address === event.returnValues.token)?.decimals || 18))).toFixed(4);
              details = `Withdrew ${withdrawAmt} ${withdrawSym}`;
              break;
            case 'BudgetApproved':
              const budgetSym = TOKENS.find(t => t.address === event.returnValues.token)?.name || 'MATIC';
              const budgetAmt = (parseFloat(event.returnValues.amount) / (10 ** (TOKENS.find(t => t.address === event.returnValues.token)?.decimals || 18))).toFixed(4);
              details = `Approved budget of ${budgetAmt} ${budgetSym}`;
              break;
            case 'BudgetRevoked':
              const revokeSym = TOKENS.find(t => t.address === event.returnValues.token)?.name || 'MATIC';
              details = `Revoked budget for ${revokeSym}`;
              break;
            case 'AutoTradingToggled':
              details = `Auto-trading ${event.returnValues.enabled ? 'enabled' : 'disabled'}`;
              break;
            case 'PriceFeedsUpdated':
              details = `Updated price feeds to ${event.returnValues.priceFeedIn}, ${event.returnValues.priceFeedOut}`;
              break;
            case 'TokensUpdated':
              const tokenInName = TOKENS.find(t => t.address === event.returnValues.tokenIn)?.name || 'MATIC';
              const tokenOutName = TOKENS.find(t => t.address === event.returnValues.tokenOut)?.name || 'MATIC';
              details = `Updated tokens to ${tokenInName} -> ${tokenOutName}`;
              break;
            default:
              details = 'Event details not formatted';
          }

          const txHash = event.transactionHash;
          const row = `<tr><td>${timestamp}</td><td>${eventName}</td><td>${details}</td><td><a href="${POLYGONSCAN_URL}${txHash}" target="_blank">${txHash.slice(0, 6)}...</a></td></tr>`;
          logTableBody.insertAdjacentHTML('beforeend', row);
        }
      } catch (error) {
        logMessage('Failed to update transaction log.');
      }
    }

    function logMessage(message) {
      const logTableBody = document.getElementById("logTable").getElementsByTagName("tbody")[0];
      const timestamp = new Date().toLocaleString();
      const row = `<tr><td>${timestamp}</td><td>Log</td><td>${message}</td><td>-</td></tr>`;
      logTableBody.insertAdjacentHTML('beforeend', row);
      const logTable = document.getElementById("logTable");
      while (logTableBody.children.length > 50) {
        logTableBody.removeChild(logTableBody.firstChild);
      }
      logTable.scrollTop = logTable.scrollHeight;
    }

    function toggleSidebar() {
      const sidebar = document.getElementById('sidebar');
      sidebar.classList.toggle('hidden');
    }
  </script>
</body>
</html>
