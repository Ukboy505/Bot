<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Advanced Trading Bot for Polygon Network">
  <title>Trading Bot Dashboard</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

  <style>
    /* Reset and Global Styles */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

body {
  font-family: 'Inter', sans-serif;
  background-color: #1a1a1a;
  color: #e0e0e0;
  line-height: 1.5;
  font-size: 16px;
}

.container {
  display: flex;
  min-height: 100vh;
}

/* Sidebar */
.sidebar {
  width: 280px;
  background-color: #222222;
  padding: 20px;
  transition: transform 0.3s ease;
  border-right: 1px solid #333;
}

.sidebar-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
}

.sidebar-header h1 {
  font-size: 24px;
  font-weight: 600;
}

.sidebar-toggle {
  background: none;
  border: none;
  color: #e0e0e0;
  font-size: 24px;
  cursor: pointer;
}

.main-toggle {
  background: none;
  border: none;
  color: #e0e0e0;
  font-size: 24px;
  cursor: pointer;
  position: absolute;
  top: 10px;
  right: 10px; /* Position on the right side */
  z-index: 1001;
  display: none; /* Hidden by default */
}

.sidebar:not(.hidden) + .main-content .main-toggle {
  display: none; /* Hidden when sidebar is visible */
}

.sidebar.hidden + .main-content .main-toggle {
  display: block; /* Visible when sidebar is hidden */
}

.wallet-section, .contract-status, .timeframe-section {
  margin-bottom: 20px;
}

.wallet-section p, .contract-status p, .timeframe-section p {
  font-size: 14px;
  margin-top: 10px;
}

.contract-status .btn {
  margin-top: 10px;
}

.timeframe-section select {
  width: 100%;
  padding: 8px;
  border-radius: 4px;
  background: #333;
  color: #e0e0e0;
  border: 1px solid #444;
}

/* Main Content */
.main-content {
  flex: 1;
  padding: 20px;
  overflow-y: auto;
  position: relative;
}

.sidebar.hidden + .main-content {
  padding-top: 40px; /* Space for main-toggle when sidebar is hidden */
}

.dashboard-header {
  margin-bottom: 20px;
}

.dashboard-header h2 {
  font-size: 28px;
  font-weight: 600;
}

.dashboard-header p {
  font-size: 14px;
  color: #a0a0a0;
}

/* Card */
.card {
  background: #252525;
  border-radius: 8px;
  padding: 20px;
  margin-bottom: 20px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

.card h3 {
  font-size: 20px;
  font-weight: 600;
  margin-bottom: 15px;
}

/* Form Grid */
.form-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 15px;
}

.form-group {
  display: flex;
  flex-direction: column;
}

.form-group label {
  font-size: 14px;
  margin-bottom: 5px;
  color: #a0a0a0;
}

.form-group input, .form-group select {
  padding: 10px;
  border-radius: 4px;
  border: 1px solid #444;
  background: #333;
  color: #e0e0e0;
  font-size: 14px;
  transition: border-color 0.2s;
}

.form-group input:focus, .form-group select:focus {
  outline: none;
  border-color: #007bff;
}

.form-group p {
  font-size: 12px;
  color: #a0a0a0;
  margin-top: 5px;
}

/* Buttons */
.btn {
  padding: 10px 20px;
  border: none;
  border-radius: 4px;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  transition: background-color 0.2s, transform 0.1s;
}

.btn-primary {
  background-color: #007bff;
  color: #fff;
}

.btn-primary:hover {
  background-color: #0056b3;
}

.btn-secondary {
  background-color: #444;
  color: #e0e0e0;
}

.btn-secondary:hover {
  background-color: #555;
}

.btn-buy {
  background-color: #28a745;
  color: #fff;
}

.btn-buy:hover {
  background-color: #218838;
}

.btn-sell {
  background-color: #dc3545;
  color: #fff;
}

.btn-sell:hover {
  background-color: #c82333;
}

.btn-danger {
  background-color: #dc3545;
  color: #fff;
}

.btn-danger:hover {
  background-color: #c82333;
}

.btn-success {
  background-color: #28a745;
  color: #fff;
}

.btn-success:hover {
  background-color: #218838;
}

.btn-toggle {
  background-color: #ffc107;
  color: #000;
}

.btn-toggle:hover {
  background-color: #e0a800;
}

.action-buttons {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  align-items: center;
}

.action-buttons p {
  font-size: 14px;
  color: #a0a0a0;
  margin-left: 10px;
}

/* Table */
table {
  width: 100%;
  border-collapse: collapse;
  margin-top: 10px;
}

th, td {
  padding: 12px;
  text-align: left;
  font-size: 14px;
}

th {
  background: #333;
  color: #e0e0e0;
  font-weight: 600;
}

td {
  border-bottom: 1px solid #444;
}

tr:hover {
  background: #2a2a2a;
}

/* Log Area */
.log-area {
  max-height: 300px;
  overflow-y: auto;
  background: #333;
  padding: 10px;
  border-radius: 4px;
  font-size: 14px;
  color: #a0a0a0;
}

.log-area a {
  color: #007bff;
  text-decoration: none;
}

.log-area a:hover {
  text-decoration: underline;
}

/* Responsive Design */
@media (max-width: 768px) {
  .container {
    flex-direction: column;
  }

  .sidebar {
    width: 100%;
    position: fixed;
    top: 0;
    left: 0;
    z-index: 1000;
    height: 100%;
    transform: translateX(0);
    transition: transform 0.3s ease;
  }

  .sidebar.hidden {
    transform: translateX(-100%);
  }

  .main-content {
    padding: 10px;
    margin-top: 0; /* Remove margin-top to ensure content is accessible */
    overflow: auto;
  }

  .form-grid {
    grid-template-columns: 1fr;
  }
}

@media (max-width: 480px) {
  .dashboard-header h2 {
    font-size: 24px;
  }

  .card h3 {
    font-size: 18px;
  }

  .btn {
    padding: 8px 16px;
    font-size: 12px;
  }

  th, td {
    font-size: 12px;
    padding: 8px;
  }
}

/* Accessibility */
:focus {
  outline: 2px solid #007bff;
  outline-offset: 2px;
}

[aria-live="polite"] {
  overflow-anchor: none;
}

/* Scrollbar */
::-webkit-scrollbar {
  width: 8px;
}

::-webkit-scrollbar-track {
  background: #333;
}

::-webkit-scrollbar-thumb {
  background: #555;
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: #666;
}
  </style>
</head>
<body>
  <div class="container">
    <!-- Sidebar (Visible on Load) -->
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <h1>Trading Bot</h1>
        <button class="sidebar-toggle" aria-label="Toggle Sidebar" onclick="toggleSidebar()">☰</button>
      </div>
      <div class="wallet-section">
        <button id="connectButton" class="btn btn-primary" onclick="connectWallet()">Connect Wallet</button>
        <button id="disconnectButton" class="btn btn-secondary" onclick="disconnectWallet()" style="display: none;">Disconnect Wallet</button>
        <p id="walletStatus">Wallet: Not Connected</p>
        <p id="nativeBalance">Native Balance: 0 MATIC</p>
        <p id="pnlStatus">PnL: $0.00 (Since 12:00 AM WAT)</p>
      </div>
      <div class="contract-status">
        <p id="contractStatus">Contract Status: Active</p>
        <button id="pauseButton" class="btn btn-danger" onclick="pauseContract()">Pause Contract</button>
        <button id="unpauseButton" class="btn btn-success" onclick="unpauseContract()" style="display: none;">Unpause Contract</button>
      </div>
      <div class="timeframe-section">
        <label for="timeframe">Timeframe:</label>
        <select id="timeframe" onchange="setTimeframe()">
          <option value="1m">1 Minute</option>
          <option value="5m" selected>5 Minutes</option>
          <option value="15m">15 Minutes</option>
          <option value="1h">1 Hour</option>
        </select>
      </div>
    </aside>

    <!-- Main Content -->
    <main class="main-content">
      <button class="main-toggle" aria-label="Toggle Sidebar" onclick="toggleSidebar()">☰</button>
      <!-- Dashboard Header -->
      <header class="dashboard-header">
        <h2>Dashboard</h2>
        <p id="priceStatus">Prices: Loading...</p>
      </header>

      <!-- Token Selection -->
      <section class="card token-selection">
        <h3>Token Pair</h3>
        <div class="form-grid">
          <div class="form-group">
            <label for="tokenIn">Token In:</label>
            <select id="tokenIn" onchange="updateTokenDropdowns()">
              <option value="" disabled selected>Select Token</option>
            </select>
            <p id="tokenInInfo">Balance: 0.0000 | Value: $0.00</p>
          </div>
          <div class="form-group">
            <label for="tokenOut">Token Out:</label>
            <select id="tokenOut" onchange="updateTokenDropdowns()">
              <option value="" disabled selected>Select Token</option>
            </select>
            <p id="tokenOutInfo">Balance: 0.0000 | Value: $0.00</p>
          </div>
          <div class="form-group">
            <label for="priceFeedIn">Price Feed In:</label>
            <input type="text" id="priceFeedIn" placeholder="Chainlink Price Feed Address">
          </div>
          <div class="form-group">
            <label for="priceFeedOut">Price Feed Out:</label>
            <input type="text" id="priceFeedOut" placeholder="Chainlink Price Feed Address">
          </div>
        </div>
        <button class="btn btn-secondary" onclick="setTokensAndFeeds()">Set Tokens & Feeds</button>
      </section>

      <!-- Trading Parameters -->
      <section class="card trading-parameters">
        <h3>Trading Parameters</h3>
        <div class="form-grid">
          <div class="form-group">
            <label for="profitRange">Profit Range (%):</label>
            <input type="number" id="profitRange" value="1" min="0" step="0.1">
          </div>
          <div class="form-group">
            <label for="stopLoss">Stop Loss (%):</label>
            <input type="number" id="stopLoss" value="1" min="0" step="0.1">
          </div>
          <div class="form-group">
            <label for="slippage">Slippage (%):</label>
            <input type="number" id="slippage" value="1" min="0" step="0.1">
          </div>
        </div>
        <button class="btn btn-secondary" onclick="setTradingParameters()">Set Parameters</button>
      </section>

      <!-- Technical Parameters -->
      <section class="card technical-parameters">
        <h3>Technical Analysis Parameters</h3>
        <div class="form-grid">
          <div class="form-group">
            <label for="macdFast">MACD Fast:</label>
            <input type="number" id="macdFast" value="12" min="1">
          </div>
          <!-- ... (other form groups remain unchanged) ... -->
          <div class="form-group">
            <label for="minSignals">Minimum Signals:</label>
            <input type="number" id="minSignals" value="2" min="1" max="7" onchange="setMinSignals()">
          </div>
        </div>
        <button class="btn btn-secondary" onclick="setTechnicalParameters()">Set Technical Parameters</button>
      </section>

      <!-- Trading Actions -->
      <section class="card trading-actions">
        <h3>Trading Actions</h3>
        <div class="action-buttons">
          <div class="form-group">
            <label for="buyAmount">Buy Amount:</label>
            <input type="number" id="buyAmount" value="1" min="0" step="0.01">
          </div>
          <button class="btn btn-buy" onclick="manualBuy()">Buy</button>
          <p id="buyResult">Result: None</p>
          <div class="form-group">
            <label for="sellAmount">Sell Amount:</label>
            <input type="number" id="sellAmount" value="1" min="0" step="0.01">
          </div>
          <button class="btn btn-sell" onclick="manualSell()">Sell</button>
          <p id="sellResult">Result: None</p>
          <button class="btn btn-toggle" onclick="toggleAutoTrading()">Toggle Auto-Trading (Off)</button>
          <p id="autoTradingStatus">Auto-Trading: Off</p>
        </div>
      </section>

      <!-- Signals Table -->
      <section class="card signals-table">
        <h3>Market Signals</h3>
        <table id="tokenSignals">
          <thead>
            <tr>
              <th>Token</th>
              <th>Signals</th>
              <th>RSI</th>
              <th>MACD</th>
              <th>Indicators & Patterns</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
        <p id="analysisResult">Market Analysis: Loading...</p>
      </section>

      <!-- Wallet Balances -->
      <section class="card wallet-balances">
        <h3>Wallet Balances</h3>
        <table id="walletBalances">
          <thead>
            <tr>
              <th>Token</th>
              <th>Balance</th>
              <th>USD Value</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </section>

      <!-- Funding Actions -->
      <section class="card funding-actions">
        <h3>Funding</h3>
        <div class="form-grid">
          <div class="form-group">
            <label for="topUpToken">Top-Up Token:</label>
            <select id="topUpToken"></select>
            <label for="topUpAmount">Amount:</label>
            <input type="number" id="topUpAmount" value="0" min="0" step="0.01">
            <p id="topUpValue">Value: $0.00</p>
            <button class="btn btn-secondary" onclick="topUpContract()">Top Up</button>
            <p id="topUpResult">Result: None</p>
          </div>
          <div class="form-group">
            <label for="budgetToken">Budget Token:</label>
            <select id="budgetToken"></select>
            <label for="budgetAmount">Amount:</label>
            <input type="number" id="budgetAmount" value="0" min="0" step="0.01">
            <p id="budgetValue">Value: $0.00</p>
            <button class="btn btn-secondary" onclick="approveBudget()">Approve Budget</button>
            <button class="btn btn-danger" onclick="revokeBudget()">Revoke Budget</button>
            <p id="budgetStatus">Budget: 0 MATIC</p>
          </div>
          <div class="form-group">
            <label for="withdrawToken">Withdraw Token:</label>
            <select id="withdrawToken"></select>
            <label for="withdrawAmount">Amount:</label>
            <input type="number" id="withdrawAmount" value="0" min="0" step="0.01">
            <p id="withdrawValue">Value: $0.00</p>
            <button class="btn btn-secondary" onclick="withdrawFunds()">Withdraw</button>
            <p id="withdrawResult">Result: None</p>
          </div>
        </div>
      </section>

      <!-- Log Area -->
      <section class="card log-area">
        <h3>Transaction Logs</h3>
        <div id="logArea" role="log" aria-live="polite"></div>
      </section>
    </main>
  </div>

  <script type="text/javascript">
    const CONTRACT_ADDRESS = '0x56672b9dde9d6d10cd5dd10fc8579a425c24ac02';
    const QUICKSWAP_ROUTER = '0xa5E0829CaCEd8fFDD4De3c43696c57F7D7A678ff';
    const NATIVE_ADDRESS = '0x0000000000000000000000000000000000000000';
    const POLYGONSCAN_URL = 'https://polygonscan.com/tx/';

    // Predefined tokens
    const TOKENS = [
      { name: 'USDT', address: '0xc2132D05D31c914a87C6611C10748AEb04B58e8F', decimals: 6, coingeckoId: 'tether' },
      { name: 'USDC', address: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174', decimals: 6, coingeckoId: 'usd-coin' },
      { name: 'DAI', address: '0x8f3Cf7ad23Cd3CaDbD9735AFf958023239c6A063', decimals: 18, coingeckoId: 'dai' },
      { name: 'POL', address: '0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270', decimals: 18, coingeckoId: 'matic-network' },
      { name: 'ADA', address: '0xE6a991fF0bf2C1a599c7057b7865b03aC15bF4B2', decimals: 18, coingeckoId: 'cardano' },
      { name: 'WETH', address: '0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619', decimals: 18, coingeckoId: 'weth' },
      { name: 'WBTC', address: '0x1BFD67037B42Cf73acF2047067bd4F2C47D9BfD6', decimals: 8, coingeckoId: 'wrapped-bitcoin' }
    ];

    // Global state
    let web3, account, contract;
    let autoTradingActive = false;
    let autoTradingInterval;
    let tokenIn, tokenOut, priceFeedIn, priceFeedOut, tokenInDecimals, tokenOutDecimals;
    let timeframe = '5m';
    let tradingParams = { profitRange: 1, stopLoss: 1, slippage: 1 };
    let techParams = {
      macdFast: 12,
      macdSlow: 26,
      macdSignal: 9,
      rsiPeriod: 14,
      minRsi: 30,
      maxRsi: 70,
      volumePeriod: 14,
      minVolumeSpike: 1.5,
      maxVolumeSpike: 3.0,
      emaPeriod: 20,
      bollingerPeriod: 20,
      bollingerStdDev: 2,
      minSignals: 2
    };
    let dailyPnL = 0;
    let lastPnLReset = 0;

    // TradingBot ABI
    const CONTRACT_ABI = [
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "_router",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "_wrappedNative",
				"type": "address"
			}
		],
		"stateMutability": "nonpayable",
		"type": "constructor"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "owner",
				"type": "address"
			}
		],
		"name": "OwnableInvalidOwner",
		"type": "error"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "account",
				"type": "address"
			}
		],
		"name": "OwnableUnauthorizedAccount",
		"type": "error"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": false,
				"internalType": "bool",
				"name": "enabled",
				"type": "bool"
			}
		],
		"name": "AutoTradingToggled",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "token",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "amount",
				"type": "uint256"
			}
		],
		"name": "BudgetApproved",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "token",
				"type": "address"
			}
		],
		"name": "BudgetRevoked",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "previousOwner",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "address",
				"name": "newOwner",
				"type": "address"
			}
		],
		"name": "OwnershipTransferred",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": false,
				"internalType": "address",
				"name": "account",
				"type": "address"
			}
		],
		"name": "Paused",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "priceFeedIn",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "address",
				"name": "priceFeedOut",
				"type": "address"
			}
		],
		"name": "PriceFeedsUpdated",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "tokenIn",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "amountIn",
				"type": "uint256"
			},
			{
				"indexed": true,
				"internalType": "address",
				"name": "tokenOut",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "amountOut",
				"type": "uint256"
			},
			{
				"indexed": false,
				"internalType": "int256",
				"name": "usdProfit",
				"type": "int256"
			}
		],
		"name": "Swapped",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "tokenIn",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "address",
				"name": "tokenOut",
				"type": "address"
			}
		],
		"name": "TokensUpdated",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "token",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "amount",
				"type": "uint256"
			}
		],
		"name": "ToppedUp",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": false,
				"internalType": "address",
				"name": "account",
				"type": "address"
			}
		],
		"name": "Unpaused",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "token",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "amount",
				"type": "uint256"
			}
		],
		"name": "Withdrawn",
		"type": "event"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "amount",
				"type": "uint256"
			}
		],
		"name": "approveNativeBudget",
		"outputs": [],
		"stateMutability": "payable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "token",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "amount",
				"type": "uint256"
			}
		],
		"name": "approveTokenBudget",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "amountIn",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "amountOutMin",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "minUSDValueOut",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "deadline",
				"type": "uint256"
			}
		],
		"name": "autoNativeSwap",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "amountIn",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "amountOutMin",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "minUSDValueOut",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "deadline",
				"type": "uint256"
			}
		],
		"name": "autoTokenSwap",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"name": "autoTradeBudget",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "autoTradingEnabled",
		"outputs": [
			{
				"internalType": "bool",
				"name": "",
				"type": "bool"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "getBalance",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "nativeBalance",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "amountIn",
				"type": "uint256"
			}
		],
		"name": "getExpectedOutput",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "priceFeed",
				"type": "address"
			}
		],
		"name": "getUSDPrice",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "amount",
				"type": "uint256"
			},
			{
				"internalType": "address",
				"name": "priceFeed",
				"type": "address"
			}
		],
		"name": "getUSDValue",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "amountIn",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "amountOutMin",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "minUSDValueOut",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "deadline",
				"type": "uint256"
			}
		],
		"name": "manualNativeSwap",
		"outputs": [],
		"stateMutability": "payable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "amountIn",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "amountOutMin",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "minUSDValueOut",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "deadline",
				"type": "uint256"
			}
		],
		"name": "manualTokenSwap",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "owner",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "pause",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "paused",
		"outputs": [
			{
				"internalType": "bool",
				"name": "",
				"type": "bool"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "priceFeedIn",
		"outputs": [
			{
				"internalType": "contract AggregatorV3Interface",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "priceFeedOut",
		"outputs": [
			{
				"internalType": "contract AggregatorV3Interface",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "renounceOwnership",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "token",
				"type": "address"
			}
		],
		"name": "revokeBudget",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "router",
		"outputs": [
			{
				"internalType": "contract IUniswapV2Router",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "_priceFeedIn",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "_priceFeedOut",
				"type": "address"
			}
		],
		"name": "setPriceFeeds",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "_tokenIn",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "_tokenOut",
				"type": "address"
			}
		],
		"name": "setTokens",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "bool",
				"name": "enable",
				"type": "bool"
			}
		],
		"name": "toggleAutoTrading",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "tokenIn",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "tokenOut",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "topUpNative",
		"outputs": [],
		"stateMutability": "payable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "token",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "amount",
				"type": "uint256"
			}
		],
		"name": "topUpToken",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "newOwner",
				"type": "address"
			}
		],
		"name": "transferOwnership",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "unpause",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "token",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "amount",
				"type": "uint256"
			}
		],
		"name": "withdraw",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "wrappedNative",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"stateMutability": "payable",
		"type": "receive"
	}
];
    
    const ERC20_ABI = [
      "function balanceOf(address) view returns (uint256)",
      "function approve(address spender, uint256 amount) external returns (bool)",
      "function transferFrom(address sender, address recipient, uint256 amount) external returns (bool)",
      "function decimals() view returns (uint8)"
    ];

    // Address validation regex
    const ADDRESS_REGEX = /^0x[0-9a-fA-F]{40}$/;

    // Fetch token decimals
    async function getTokenDecimals(tokenAddress) {
      if (tokenAddress === NATIVE_ADDRESS) return 18;
      try {
        const tokenContract = new web3.eth.Contract(ERC20_ABI, tokenAddress);
        const decimals = await tokenContract.methods.decimals().call();
        return Number(decimals);
      } catch (error) {
        logMessage(`Failed to fetch decimals for ${tokenAddress}: ${error.message}. Assuming 0 decimals.`);
        return 0; // Allow non-standard tokens
      }
    }

    // Initialize token dropdowns (unchanged)
    function initializeTokenDropdowns() {
      const tokenInSelect = document.getElementById("tokenIn");
      const tokenOutSelect = document.getElementById("tokenOut");
      const budgetSelect = document.getElementById("budgetToken");
      const topUpSelect = document.getElementById("topUpToken");
      const withdrawSelect = document.getElementById("withdrawToken");

      TOKENS.forEach(token => {
        const option = `<option value="${token.address}">${token.name}</option>`;
        tokenInSelect.insertAdjacentHTML('beforeend', option);
        tokenOutSelect.insertAdjacentHTML('beforeend', option);
        budgetSelect.insertAdjacentHTML('beforeend', option);
        topUpSelect.insertAdjacentHTML('beforeend', option);
        withdrawSelect.insertAdjacentHTML('beforeend', option);
      });

      const nativeOption = `<option value="${NATIVE_ADDRESS}">MATIC</option>`;
      tokenInSelect.insertAdjacentHTML('beforeend', nativeOption);
      tokenOutSelect.insertAdjacentHTML('beforeend', nativeOption);
      budgetSelect.insertAdjacentHTML('beforeend', nativeOption);
      topUpSelect.insertAdjacentHTML('beforeend', nativeOption);
      withdrawSelect.insertAdjacentHTML('beforeend', nativeOption);
    }

    // Update token dropdowns
    async function updateTokenDropdowns() {
      const tokenInSelect = document.getElementById("tokenIn");
      const tokenOutSelect = document.getElementById("tokenOut");
      const tokenInValue = tokenInSelect.value;
      const tokenOutValue = tokenOutSelect.value;

      Array.from(tokenInSelect.options).forEach(option => {
        option.disabled = option.value === tokenOutValue && option.value !== "";
      });
      Array.from(tokenOutSelect.options).forEach(option => {
        option.disabled = option.value === tokenInValue && option.value !== "";
      });

      if (tokenInValue) {
        const token = TOKENS.find(t => t.address === tokenInValue) || { name: 'MATIC', decimals: 18, coingeckoId: 'matic-network' };
        tokenInDecimals = await getTokenDecimals(tokenInValue);
        const balance = await getContractBalance(tokenInValue);
        const usdValue = await getCoinGeckoPrice(token.coingeckoId) * balance;
        document.getElementById("tokenInInfo").innerText = `Balance: ${balance.toFixed(4)} | Value: $${usdValue.toFixed(2)} | Decimals: ${tokenInDecimals}`;
        if (balance === 0) logMessage(`${token.name} has no balance in contract`);
      }
      if (tokenOutValue) {
        const token = TOKENS.find(t => t.address === tokenOutValue) || { name: 'MATIC', decimals: 18, coingeckoId: 'matic-network' };
        tokenOutDecimals = await getTokenDecimals(tokenOutValue);
        const balance = await getContractBalance(tokenOutValue);
        const usdValue = await getCoinGeckoPrice(token.coingeckoId) * balance;
        document.getElementById("tokenOutInfo").innerText = `Balance: ${balance.toFixed(4)} | Value: $${usdValue.toFixed(2)} | Decimals: ${tokenOutDecimals}`;
        if (balance === 0) logMessage(`${token.name} has no balance in contract`);
      }
    }

    // Update withdraw dropdown
    async function updateWithdrawDropdown() {
      const withdrawSelect = document.getElementById("withdrawToken");
      withdrawSelect.innerHTML = '<option value="" disabled selected>Select Token</option>';
      for (const token of TOKENS.concat([{ name: 'MATIC', address: NATIVE_ADDRESS, decimals: 18, coingeckoId: 'matic-network' }])) {
        const decimals = await getTokenDecimals(token.address);
        const balance = await getContractBalance(token.address);
        const usdValue = await getCoinGeckoPrice(token.coingeckoId) * balance;
        if (balance > 0 && usdValue > 0) {
          withdrawSelect.insertAdjacentHTML('beforeend', `<option value="${token.address}">${token.name} (Bal: ${balance.toFixed(4)}, $${usdValue.toFixed(2)}, Dec: ${decimals})</option>`);
        }
      }
    }

    // Update native balance
    async function updateNativeBalance() {
      if (!contract) return;
      try {
        const balance = await contract.methods.getBalance().call();
        const formattedBalance = web3.utils.fromWei(balance, 'ether');
        document.getElementById("nativeBalance").innerText = `Native Balance: ${parseFloat(formattedBalance).toFixed(4)} MATIC`;
      } catch (error) {
        logMessage(`Failed to fetch native balance: ${error.message}`);
      }
    }

    // Connect wallet
    async function connectWallet() {
      if (!window.ethereum) {
        logMessage("MetaMask not detected");
        return;
      }
      try {
        web3 = new Web3(window.ethereum);
        await window.ethereum.request({ method: 'eth_requestAccounts' });
        account = (await web3.eth.getAccounts())[0];
        contract = new web3.eth.Contract(CONTRACT_ABI, CONTRACT_ADDRESS);
        document.getElementById("walletStatus").innerText = `Wallet: ${account}`;
        logMessage(`Connected wallet: ${account}`);
        document.getElementById('connectButton').style.display = 'none';
        document.getElementById('disconnectButton').style.display = 'block';
        initializeTokenDropdowns();
        updatePrices();
        updateBudgetStatus();
        updateWalletBalances();
        updateWithdrawDropdown();
        updateNativeBalance();
        updatePnL();
        updateContractStatus();
        setInterval(updatePnL, 10 * 60 * 1000);
        setInterval(updateNativeBalance, 30 * 1000);
      } catch (error) {
        logMessage(`Connection failed: ${error.message}`);
      }
    }

    // Disconnect wallet
    function disconnectWallet() {
      account = null;
      contract = null;
      web3 = null;
      document.getElementById('walletStatus').innerText = 'Wallet: Not Connected';
      document.getElementById('nativeBalance').innerText = 'Native Balance: 0 MATIC';
      logMessage('Wallet disconnected');
      document.getElementById('connectButton').style.display = 'block';
      document.getElementById('disconnectButton').style.display = 'none';
    }

    // Check contract paused state
    async function isContractPaused() {
      if (!contract) return false;
      try {
        return await contract.methods.paused().call();
      } catch (error) {
        logMessage(`Error checking paused state: ${error.message}`);
        return false;
      }
    }

    // Update contract status UI
    async function updateContractStatus() {
      const isPaused = await isContractPaused();
      document.getElementById("contractStatus").innerText = `Contract Status: ${isPaused ? 'Paused' : 'Active'}`;
      document.getElementById("pauseButton").style.display = isPaused ? 'none' : 'block';
      document.getElementById("unpauseButton").style.display = isPaused ? 'block' : 'none';
    }

    // Pause contract
    async function pauseContract() {
      if (!contract) {
        logMessage("Please connect wallet first");
        return;
      }
      try {
        const tx = await contract.methods.pause().send({ from: account });
        logMessage(`Contract paused - Tx: <a href="${POLYGONSCAN_URL}${tx.transactionHash}" target="_blank">${tx.transactionHash}</a>`);
        await updateContractStatus();
      } catch (error) {
        logMessage(`Pause failed: ${error.message}`);
      }
    }

    // Unpause contract
    async function unpauseContract() {
      if (!contract) {
        logMessage("Please connect wallet first");
        return;
      }
      try {
        const tx = await contract.methods.unpause().send({ from: account });
        logMessage(`Contract unpaused - Tx: <a href="${POLYGONSCAN_URL}${tx.transactionHash}" target="_blank">${tx.transactionHash}</a>`);
        await updateContractStatus();
      } catch (error) {
        logMessage(`Unpause failed: ${error.message}`);
      }
    }

    // Set timeframe (unchanged)
    function setTimeframe() {
      timeframe = document.getElementById("timeframe").value;
      logMessage(`Timeframe set to ${timeframe}`);
      updateSignals();
    }

    // Set tokens and price feeds
    async function setTokensAndFeeds() {
      try {
        tokenIn = document.getElementById("tokenIn").value;
        tokenOut = document.getElementById("tokenOut").value;
        priceFeedIn = document.getElementById("priceFeedIn").value;
        priceFeedOut = document.getElementById("priceFeedOut").value;

        if (!ADDRESS_REGEX.test(tokenIn) || !ADDRESS_REGEX.test(tokenOut) ||
            !ADDRESS_REGEX.test(priceFeedIn) || !ADDRESS_REGEX.test(priceFeedOut)) {
          throw new Error("Invalid address format");
        }

        tokenInDecimals = await getTokenDecimals(tokenIn);
        tokenOutDecimals = await getTokenDecimals(tokenOut);

        const tx = await contract.methods.setTokens(tokenIn, tokenOut).send({ from: account });
        logMessage(`Tokens set: ${tokenIn} -> ${tokenOut} - Tx: <a href="${POLYGONSCAN_URL}${tx.transactionHash}" target="_blank">${tx.transactionHash}</a>`);

        const tx2 = await contract.methods.setPriceFeeds(priceFeedIn, priceFeedOut).send({ from: account });
        logMessage(`Price feeds set: ${priceFeedIn}, ${priceFeedOut} - Tx: <a href="${POLYGONSCAN_URL}${tx2.transactionHash}" target="_blank">${tx2.transactionHash}</a>`);

        updatePrices();
      } catch (error) {
        logMessage(`Failed to set tokens/feeds: ${error.message}`);
      }
    }

    // Set trading parameters (unchanged)
    function setTradingParameters() {
      tradingParams.profitRange = parseFloat(document.getElementById("profitRange").value);
      tradingParams.stopLoss = parseFloat(document.getElementById("stopLoss").value);
      tradingParams.slippage = parseFloat(document.getElementById("slippage").value);
      logMessage(`Trading parameters set - Profit: ${tradingParams.profitRange}%, Stop Loss: ${tradingParams.stopLoss}%, Slippage: ${tradingParams.slippage}%`);
    }

    // Set technical parameters (unchanged)
    function setTechnicalParameters() {
      techParams.macdFast = parseInt(document.getElementById("macdFast").value);
      techParams.macdSlow = parseInt(document.getElementById("macdSlow").value);
      techParams.macdSignal = parseInt(document.getElementById("macdSignal").value);
      techParams.rsiPeriod = parseInt(document.getElementById("rsiPeriod").value);
      techParams.minRsi = parseInt(document.getElementById("minRsi").value);
      techParams.maxRsi = parseInt(document.getElementById("maxRsi").value);
      techParams.volumePeriod = parseInt(document.getElementById("volumePeriod").value);
      techParams.minVolumeSpike = parseFloat(document.getElementById("minVolumeSpike").value);
      techParams.maxVolumeSpike = parseFloat(document.getElementById("maxVolumeSpike").value);
      techParams.emaPeriod = parseInt(document.getElementById("emaPeriod").value);
      techParams.bollingerPeriod = parseInt(document.getElementById("bollingerPeriod").value);
      techParams.bollingerStdDev = parseFloat(document.getElementById("bollingerStdDev").value);
      logMessage("Technical parameters updated");
      updateSignals();
    }

    // Set minimum signals (unchanged)
    function setMinSignals() {
      techParams.minSignals = parseInt(document.getElementById("minSignals").value);
      logMessage(`Minimum signals set to ${techParams.minSignals}`);
      updateSignals();
    }

    // Fetch CoinGecko price (unchanged)
    async function getCoinGeckoPrice(coingeckoId) {
      try {
        const response = await fetch(`https://api.coingecko.com/api/v3/simple/price?ids=${coingeckoId}&vs_currencies=usd`);
        const data = await response.json();
        return data[coingeckoId].usd;
      } catch (error) {
        logMessage(`CoinGecko price fetch failed: ${error.message}`);
        return 0;
      }
    }

    // Update prices
    async function updatePrices() {
      if (!contract || !tokenIn || !tokenOut) return;
      try {
        const amountIn = (1 * (10 ** tokenInDecimals)).toString();
        const amountOut = (1 * (10 ** tokenOutDecimals)).toString();
        const usdValueIn = web3.utils.fromWei(await contract.methods.getUSDValue(amountIn, priceFeedIn).call(), 'ether');
        const usdValueOut = web3.utils.fromWei(await contract.methods.getUSDValue(amountOut, priceFeedOut).call(), 'ether');
        document.getElementById("priceStatus").innerText = `Prices: 1 ${TOKENS.find(t => t.address === tokenIn)?.name || 'MATIC'} = $${usdValueIn}, 1 ${TOKENS.find(t => t.address === tokenOut)?.name || 'MATIC'} = $${usdValueOut}`;
      } catch (error) {
        document.getElementById("priceStatus").innerText = `Prices: Error fetching prices`;
        logMessage(`Price update failed: ${error.message}`);
      }
    }

    // Get contract balance
    async function getContractBalance(tokenAddress) {
      if (!contract) return 0;
      try {
        if (tokenAddress === NATIVE_ADDRESS) {
          const balance = await contract.methods.getBalance().call();
          return parseFloat(web3.utils.fromWei(balance, 'ether'));
        } else {
          const tokenContract = new web3.eth.Contract(ERC20_ABI, tokenAddress);
          const decimals = await getTokenDecimals(tokenAddress);
          const balance = await tokenContract.methods.balanceOf(CONTRACT_ADDRESS).call();
          return parseFloat(balance) / (10 ** decimals);
        }
      } catch (error) {
        logMessage(`Balance fetch failed for ${tokenAddress}: ${error.message}`);
        return 0;
      }
    }

    // Update wallet balances
    async function updateWalletBalances() {
      if (!account) return;
      const tbody = document.getElementById("walletBalances").getElementsByTagName("tbody")[0];
      tbody.innerHTML = "";
      for (const token of TOKENS.concat([{ name: 'MATIC', address: NATIVE_ADDRESS, decimals: 18, coingeckoId: 'matic-network' }])) {
        const decimals = await getTokenDecimals(token.address);
        let balance;
        if (token.address === NATIVE_ADDRESS) {
          balance = await web3.eth.getBalance(account);
          balance = parseFloat(web3.utils.fromWei(balance, 'ether'));
        } else {
          const tokenContract = new web3.eth.Contract(ERC20_ABI, token.address);
          balance = await tokenContract.methods.balanceOf(account).call();
          balance = parseFloat(balance) / (10 ** decimals);
        }
        const usdValue = await getCoinGeckoPrice(token.coingeckoId) * balance;
        if (balance > 0) {
          tbody.insertAdjacentHTML('beforeend', `<tr><td>${token.name}</td><td>${balance.toFixed(4)}</td><td>$${usdValue.toFixed(2)}</td></tr>`);
        }
      }
    }

    // Update PnL (unchanged)
    async function updatePnL() {
      const now = Date.now();
      const WAT_OFFSET = 1 * 60 * 60 * 1000; // WAT is UTC+1
      const midnightWAT = new Date(now - (now % (24 * 60 * 60 * 1000)) - WAT_OFFSET + 24 * 60 * 60 * 1000);
      if (lastPnLReset < midnightWAT.getTime()) {
        dailyPnL = 0;
        lastPnLReset = midnightWAT.getTime();
      }
      document.getElementById("pnlStatus").innerText = `PnL: $${dailyPnL.toFixed(2)} (Since 12:00 AM WAT)`;
    }

    // Simulate fetching market data (unchanged)
    async function fetchMarketData(token, timeframe) {
      const prices = Array(50).fill().map(() => Math.random() * 100 + 50);
      const volumes = Array(50).fill().map(() => Math.random() * 1000);
      return { prices, volumes };
    }

    // Update market signals (unchanged)
    async function updateSignals() {
      if (!tokenIn || !tokenOut) return;
      const tbody = document.getElementById("tokenSignals").getElementsByTagName("tbody")[0];
      tbody.innerHTML = "";

      const tokens = [tokenIn, tokenOut].map(addr => TOKENS.find(t => t.address === addr) || { name: 'MATIC', coingeckoId: 'matic-network' });
      for (const token of tokens) {
        const { prices, volumes } = await fetchMarketData(token.address, timeframe);
        const signals = calculateSignals(prices, volumes);
        tbody.insertAdjacentHTML('beforeend', `
          <tr>
            <td>${token.name}</td>
            <td>${signals.count}</td>
            <td>${signals.rsi.toFixed(2)}</td>
            <td>${signals.macd.signal > 0 ? 'Bullish' : 'Bearish'}</td>
            <td>${signals.patterns.join(', ')}</td>
          </tr>
        `);
        if (signals.count >= techParams.minSignals && autoTradingActive) {
          logMessage(`Auto-trading triggered for ${token.name} with ${signals.count} signals`);
          await autoTrade(signals.count >= techParams.minSignals ? 'buy' : 'sell');
        }
      }
      document.getElementById("analysisResult").innerText = `Market Analysis: Updated for ${timeframe}`;
    }

    // Calculate technical signals (unchanged)
    function calculateSignals(prices, volumes) {
      const rsi = technicalindicators.RSI.calculate({ values: prices, period: techParams.rsiPeriod })[0] || 0;
      const macdData = technicalindicators.MACD.calculate({
        values: prices,
        fastPeriod: techParams.macdFast,
        slowPeriod: techParams.macdSlow,
        signalPeriod: techParams.macdSignal
      });
      const macd = macdData[macdData.length - 1] || { MACD: 0, signal: 0 };
      const ema = technicalindicators.EMA.calculate({ values: prices, period: techParams.emaPeriod })[0] || 0;
      const bollinger = technicalindicators.BollingerBands.calculate({
        values: prices,
        period: techParams.bollingerPeriod,
        stdDev: techParams.bollingerStdDev
      })[0] || { upper: 0, middle: 0, lower: 0 };
      const smaVolume = technicalindicators.SMA.calculate({ values: volumes, period: techParams.volumePeriod })[0] || 0;
      const volumeSpike = volumes[volumes.length - 1] / smaVolume;

      let signals = 0;
      const patterns = [];
      if (rsi < techParams.minRsi) { signals++; patterns.push("Oversold RSI"); }
      if (rsi > techParams.maxRsi) { signals++; patterns.push("Overbought RSI"); }
      if (macd.MACD > macd.signal) { signals++; patterns.push("MACD Bullish"); }
      if (macd.MACD < macd.signal) { signals++; patterns.push("MACD Bearish"); }
      if (prices[prices.length - 1] > ema) { signals++; patterns.push("Above EMA"); }
      if (prices[prices.length - 1] > bollinger.upper) { signals++; patterns.push("Above Bollinger Upper"); }
      if (volumeSpike > techParams.minVolumeSpike && volumeSpike < techParams.maxVolumeSpike) { signals++; patterns.push("Volume Spike"); }

      return { count: signals, rsi, macd, patterns };
    }

    // Manual buy
    async function manualBuy() {
      try {
        const amount = parseFloat(document.getElementById("buyAmount").value || "1");
        const amountIn = (amount * (10 ** tokenInDecimals)).toString();
        const amountOutMin = (amount * (1 - tradingParams.slippage / 100) * (10 ** tokenOutDecimals)).toString();
        const minUSDValueOut = web3.utils.toWei("0.9", 'ether');
        const deadline = Math.floor(Date.now() / 1000) + 60 * 20;

        let tx;
        if (tokenIn === NATIVE_ADDRESS) {
          tx = await contract.methods.manualNativeSwap(amountIn, amountOutMin, minUSDValueOut, deadline).send({ from: account, value: amountIn });
        } else {
          tx = await contract.methods.manualTokenSwap(amountIn, amountOutMin, minUSDValueOut, deadline).send({ from: account });
        }
        document.getElementById("buyResult").innerText = `Result: Success - Tx: ${tx.transactionHash}`;
        logMessage(`Manual buy successful - Tx: <a href="${POLYGONSCAN_URL}${tx.transactionHash}" target="_blank">${tx.transactionHash}</a>`);
        dailyPnL += 0.1;
        updatePnL();
        updateWalletBalances();
        updateWithdrawDropdown();
        updateNativeBalance();
      } catch (error) {
        document.getElementById("buyResult").innerText = `Result: Failed - ${error.message}`;
        logMessage(`Manual buy failed: ${error.message}`);
      }
    }

    // Manual sell
    async function manualSell() {
      try {
        const amount = parseFloat(document.getElementById("sellAmount").value || "1");
        const amountIn = (amount * (10 ** tokenOutDecimals)).toString();
        const amountOutMin = (amount * (1 - tradingParams.slippage / 100) * (10 ** tokenInDecimals)).toString();
        const minUSDValueOut = web3.utils.toWei("0.9", 'ether');
        const deadline = Math.floor(Date.now() / 1000) + 60 * 20;

        const tempTokenIn = tokenIn;
        tokenIn = tokenOut;
        tokenOut = tempTokenIn;
        const tempDecimals = tokenInDecimals;
        tokenInDecimals = tokenOutDecimals;
        tokenOutDecimals = tempDecimals;

        let tx;
        if (tokenIn === NATIVE_ADDRESS) {
          tx = await contract.methods.manualNativeSwap(amountIn, amountOutMin, minUSDValueOut, deadline).send({ from: account, value: amountIn });
        } else {
          tx = await contract.methods.manualTokenSwap(amountIn, amountOutMin, minUSDValueOut, deadline).send({ from: account });
        }
        document.getElementById("sellResult").innerText = `Result: Success - Tx: ${tx.transactionHash}`;
        logMessage(`Manual sell successful - Tx: <a href="${POLYGONSCAN_URL}${tx.transactionHash}" target="_blank">${tx.transactionHash}</a>`);
        dailyPnL -= 0.05;
        updatePnL();
        updateWalletBalances();
        updateWithdrawDropdown();
        updateNativeBalance();

        tokenIn = tempTokenIn;
        tokenOut = tempTokenIn;
        tokenInDecimals = tempDecimals;
        tokenOutDecimals = await getTokenDecimals(tokenOut);
      } catch (error) {
        document.getElementById("sellResult").innerText = `Result: Failed - ${error.message}`;
        logMessage(`Manual sell failed: ${error.message}`);
      }
    }

    // Toggle auto-trading
    async function toggleAutoTrading() {
      try {
        autoTradingActive = !autoTradingActive;
        const tx = await contract.methods.toggleAutoTrading(autoTradingActive).send({ from: account });
        document.getElementById("autoTradingStatus").innerText = `Auto-Trading: ${autoTradingActive ? 'On' : 'Off'}`;
        document.getElementById("toggleAutoTrading").innerText = `Toggle Auto-Trading (${autoTradingActive ? 'On' : 'Off'})`;
        logMessage(`Auto-trading ${autoTradingActive ? 'enabled' : 'disabled'} - Tx: <a href="${POLYGONSCAN_URL}${tx.transactionHash}" target="_blank">${tx.transactionHash}</a>`);
        if (autoTradingActive) {
          autoTradingInterval = setInterval(updateSignals, 60 * 1000);
        } else {
          clearInterval(autoTradingInterval);
        }
      } catch (error) {
        logMessage(`Auto-trading toggle failed: ${error.message}`);
      }
    }

    // Auto trade
    async function autoTrade(direction) {
      try {
        const amountIn = (1 * (10 ** tokenInDecimals)).toString();
        const amountOutMin = (1 * (1 - tradingParams.slippage / 100) * (10 ** tokenOutDecimals)).toString();
        const minUSDValueOut = web3.utils.toWei("0.9", 'ether');
        const deadline = Math.floor(Date.now() / 1000) + 60 * 20;

        let tx;
        if (tokenIn === NATIVE_ADDRESS) {
          tx = await contract.methods.autoNativeSwap(amountIn, amountOutMin, minUSDValueOut, deadline).send({ from: account });
        } else {
          tx = await contract.methods.autoTokenSwap(amountIn, amountOutMin, minUSDValueOut, deadline).send({ from: account });
        }
        logMessage(`Auto ${direction} successful - Tx: <a href="${POLYGONSCAN_URL}${tx.transactionHash}" target="_blank">${tx.transactionHash}</a>`);
        dailyPnL += direction === 'buy' ? 0.1 : -0.05;
        updatePnL();
        updateWalletBalances();
        updateWithdrawDropdown();
        updateNativeBalance();
      } catch (error) {
        logMessage(`Auto ${direction} failed: ${error.message}`);
      }
    }

    // Top up contract
    async function topUpContract() {
      try {
        const token = document.getElementById("topUpToken").value;
        const decimals = await getTokenDecimals(token);
        const amount = (parseFloat(document.getElementById("topUpAmount").value) * (10 ** decimals)).toString();
        let tx;
        if (token === NATIVE_ADDRESS) {
          tx = await contract.methods.topUpNative().send({ from: account, value: amount });
        } else {
          tx = await contract.methods.topUpToken(token, amount).send({ from: account });
        }
        document.getElementById("topUpResult").innerText = `Result: Success - Tx: ${tx.transactionHash}`;
        logMessage(`Top-up successful - Tx: <a href="${POLYGONSCAN_URL}${tx.transactionHash}" target="_blank">${tx.transactionHash}</a>`);
        updateTokenDropdowns();
        updateWithdrawDropdown();
        updateNativeBalance();
      } catch (error) {
        document.getElementById("topUpResult").innerText = `Result: Failed - ${error.message}`;
        logMessage(`Top-up failed: ${error.message}`);
      }
    }

    // Approve budget
    async function approveBudget() {
      try {
        const token = document.getElementById("budgetToken").value;
        const decimals = await getTokenDecimals(token);
        const amount = (parseFloat(document.getElementById("budgetAmount").value) * (10 ** decimals)).toString();
        let tx;
        if (token === NATIVE_ADDRESS) {
          tx = await contract.methods.approveNativeBudget(amount).send({ from: account, value: amount });
        } else {
          tx = await contract.methods.approveTokenBudget(token, amount).send({ from: account });
        }
        logMessage(`Budget approved - Tx: <a href="${POLYGONSCAN_URL}${tx.transactionHash}" target="_blank">${tx.transactionHash}</a>`);
        updateBudgetStatus();
        updateNativeBalance();
      } catch (error) {
        logMessage(`Budget approval failed: ${error.message}`);
      }
    }

    // Revoke budget
    async function revokeBudget() {
      try {
        const token = document.getElementById("budgetToken").value;
        const tx = await contract.methods.revokeBudget(token).send({ from: account });
        logMessage(`Budget revoked - Tx: <a href="${POLYGONSCAN_URL}${tx.transactionHash}" target="_blank">${tx.transactionHash}</a>`);
        updateBudgetStatus();
        updateWithdrawDropdown();
        updateNativeBalance();
      } catch (error) {
        logMessage(`Budget revocation failed: ${error.message}`);
      }
    }

    // Update budget status
    async function updateBudgetStatus() {
      if (!contract) return;
      const token = document.getElementById("budgetToken").value;
      const decimals = await getTokenDecimals(token);
      const budget = await contract.methods.autoTradeBudget(token).call();
      document.getElementById("budgetStatus").innerText = `Budget: ${(parseFloat(budget) / (10 ** decimals)).toFixed(4)} ${TOKENS.find(t => t.address === token)?.name || 'MATIC'}`;
    }

    // Withdraw funds
    async function withdrawFunds() {
      try {
        const token = document.getElementById("withdrawToken").value;
        const decimals = await getTokenDecimals(token);
        const amount = (parseFloat(document.getElementById("withdrawAmount").value) * (10 ** decimals)).toString();
        const tx = await contract.methods.withdraw(token, amount).send({ from: account });
        document.getElementById("withdrawResult").innerText = `Result: Success - Tx: ${tx.transactionHash}`;
        logMessage(`Withdrawal successful - Tx: <a href="${POLYGONSCAN_URL}${tx.transactionHash}" target="_blank">${tx.transactionHash}</a>`);
        updateTokenDropdowns();
        updateWithdrawDropdown();
        updateNativeBalance();
      } catch (error) {
        document.getElementById("withdrawResult").innerText = `Result: Failed - ${error.message}`;
        logMessage(`Withdrawal failed: ${error.message}`);
      }
    }

    // Log message (unchanged)
    function logMessage(message) {
      const logArea = document.getElementById("logArea");
      logArea.insertAdjacentHTML('beforeend', `<p>${new Date().toLocaleTimeString()} - ${message}</p>`);
      logArea.scrollTop = logArea.scrollHeight;
    }

    // Toggle sidebar (unchanged)
    function toggleSidebar() {
      const sidebar = document.getElementById('sidebar');
      sidebar.classList.toggle('hidden');
    }

    // Initial setup (unchanged)
    document.addEventListener("DOMContentLoaded", () => {
      if (window.ethereum) {
        window.ethereum.on('accountsChanged', () => location.reload());
        window.ethereum.on('chainChanged', () => location.reload());
      }
    });
  </script>
  <script src="https://unpkg.com/technicalindicators@3.1.0/dist/browser.min.js"></script>
  <script src="https://unpkg.com/web3@1.7.0/dist/web3.min.js"></script>
</body>
</html>