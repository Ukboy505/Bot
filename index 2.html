<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Advanced Trading Bot for Polygon Network">
    <title>Trading Bot Dashboard</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Inter', sans-serif;
        }
        body {
            background-color: #1a1a1a;
            color: #e0e0e0;
        }
        .container {
            display: flex;
            min-height: 100vh;
        }
        .sidebar {
            width: 300px;
            background-color: #252525;
            padding: 20px;
            transition: transform 0.3s ease;
            flex-shrink: 0; /* Prevent sidebar from shrinking */
        }
        .sidebar.hidden {
            transform: translateX(-100%);
        }
        .main-content {
            flex-grow: 1;
            padding: 20px;
            background-color: #1a1a1a;
            overflow-x: hidden; /* Prevent horizontal scroll on main content */
        }
        .sidebar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        .sidebar-toggle, .main-toggle {
            background: none;
            border: none;
            color: #e0e0e0;
            font-size: 24px;
            cursor: pointer;
        }
        .card {
            background-color: #252525;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.2s;
            margin-top: 10px; /* Added for spacing */
        }
        .btn-primary {
            background-color: #007bff;
            color: #fff;
        }
        .btn-primary:hover {
            background-color: #0056b3;
        }
        .btn-secondary {
            background-color: #6c757d;
            color: #fff;
        }
        .btn-secondary:hover {
            background-color: #5a6268;
        }
        .btn-buy {
            background-color: #28a745;
            color: #fff;
        }
        .btn-buy:hover {
            background-color: #218838;
        }
        .btn-sell {
            background-color: #dc3545;
            color: #fff;
        }
        .btn-sell:hover {
            background-color: #c82333;
        }
        .btn-toggle {
            background-color: #ffc107;
            color: #000;
        }
        .btn-toggle:hover {
            background-color: #e0a800;
        }
        .form-group {
            margin-bottom: 15px;
        }
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }
        .form-group input, .form-group select {
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #444;
            background-color: #333;
            color: #e0e0e0;
        }
        .form-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        th, td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid #444;
        }
        th {
            background-color: #333;
        }
        .signal-strong {
            color: #28a745;
            font-weight: bold;
        }
        .signal-moderate {
            color: #ffc107;
        }
        .signal-weak {
            color: #6c757d;
        }
        .signal-neutral {
            color: #e0e0e0;
        }
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .modal-content {
            background: #252525;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        .modal-content input {
            margin-top: 10px;
        }
        .modal-content button {
            margin-top: 15px;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            background-color: #007bff;
            color: white;
            border: none;
        }
        .modal-content button:hover {
            background-color: #0056b3;
        }
        @media (max-width: 768px) {
            .sidebar {
                position: fixed;
                height: 100%;
                z-index: 1000;
                width: 250px; /* Adjusted width for mobile */
            }
            .main-content {
                margin-left: 0;
            }
            .form-grid {
                grid-template-columns: 1fr;
            }
        }
        #analysisResult {
            font-size: 16px;
            color: #ffffff;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
        }
        #analysisResult.warning::before {
            content: '‚ö†Ô∏è ';
            color: #ff4444;
        }
        #clearCacheButton {
            padding: 10px 20px;
            margin: 5px;
            background-color: #444;
            color: #fff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        #clearCacheButton:hover {
            background-color: #555;
        }
        .form-group input[type="number"]#nativeBudgetPercent,
        .form-group input[type="number"]#tokenBudgetPercent {
            width: auto; /* Allow natural sizing */
            max-width: 100px; /* Constrain width */
            display: inline-block; /* Keep it inline with label */
        }
        .form-group input[type="checkbox"] {
            margin: 0 10px;
            width: auto; /* Adjust for checkbox */
        }
        input.invalid {
            border-color: #ff4444;
        }
        button:disabled {
            background-color: #666;
            cursor: not-allowed;
        }
        .hint {
            font-size: 0.8em;
            color: #aaa;
        }
        .chart-container-wrapper {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .chart-title {
            text-align: center;
            margin-top: 10px;
            font-size: 1.1em;
            color: #e0e0e0;
        }

        /* Custom styles for timeframe dropdown */
        #timeframe {
            padding: 10px 15px;
            border: 1px solid #333;
            border-radius: 8px;
            background-color: #2a2a2a;
            color: #e0e0e0;
            font-size: 16px;
            font-family: 'Inter', sans-serif;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            cursor: pointer;
            outline: none;
            transition: border-color 0.3s ease, background-color 0.3s ease;
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292%22%20height%3D%22292%22%3E%3Cpath%20fill%3D%22%23e0e0e0%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13.2-6.4H18.2c-4.1%200-7.9%201.4-10.9%204.4-3%203-4.4%206.9-4.4%2010.9v160.7c0%204.1%201.4%207.9%204.4%2010.9s6.9%204.4%2010.9%204.4h255.6c4.1%200%207.9-1.4%2010.9-4.4s4.4-6.9%204.4-10.9V82.6c0-4.1-1.4-7.9-4.4-10.9z%22%2F%3E%3C%2Fsvg%3E');
            background-repeat: no-repeat;
            background-position: right 10px top 50%;
            background-size: 12px;
            padding-right: 30px; /* Make space for the custom arrow */
        }

        #timeframe:hover {
            border-color: #666;
        }

        #timeframe:focus {
            border-color: #007bff;
            box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.3);
        }

        #timeframe option {
            background-color: #3a3a3a;
            color: #e0e0e0;
            padding: 8px 15px;
        }

        /* Styling for section-specific token dropdowns */
        .section-token-select {
            width: calc(100% - 20px); /* Adjust width to fit well within form-group */
            margin-top: 5px;
            margin-bottom: 10px;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #444;
            background-color: #333;
            color: #e0e0e0;
        }
    </style>
    <script type="text/javascript" src="https://unpkg.com/lightweight-charts@5.0.7/dist/lightweight-charts.standalone.production.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios@1.7.7/dist/axios.min.js" integrity="sha256-4T1uENz1k/jUKQ2y3hKhGwI6R82k1Ej0n4V6Q0oZ/9E=" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/web3@1.7.0/dist/web3.min.js"></script>
    <script src="https://unpkg.com/ta.js/ta.min.js"></script>
</head>
<body>
    <div class="container">
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <h1>Trading Bot</h1>
                <button class="sidebar-toggle" aria-label="Toggle Sidebar" onclick="toggleSidebar()">‚ò∞</button>
            </div>
            <div class="wallet-section">
                <button id="connectButton" class="btn btn-primary" onclick="connectWallet()">Connect Wallet</button>
                <button id="disconnectButton" class="btn btn-secondary" onclick="disconnectWallet()" style="display: none;">Disconnect Wallet</button>
                <p id="walletStatus" aria-live="polite">Wallet: Not Connected</p>
                <button id="clearCacheButton" onclick="clearPairCache()">Clear Pair Cache</button>
                <p id="nativeBalance">Native Balance: 0 MATIC</p>
                <p id="pnlStatus">PnL: $0.00 (Since 12:00 AM WAT)</p>
            </div>
        </aside>

        <main class="main-content">
            <button class="main-toggle" aria-label="Toggle Sidebar" onclick="toggleSidebar()">‚ò∞</button>
            <header class="dashboard-header">
                <h2>Dashboard</h2>
                <p id="priceStatus" aria-live="polite">Prices: Loading...</p>
            </header>

            <section class="card contract-status">
                <h3>Contract Status</h3>
                <p id="contractStatus" aria-live="polite">Contract Status: Not Connected</p>
                <div class="action-buttons">
                    <button id="pauseButton" class="btn btn-danger" onclick="pauseContract()" style="display: none;">Pause Contract</button>
                    <button id="unpauseButton" class="btn btn-success" onclick="unpauseContract()" style="display: none;">Unpause Contract</button>
                </div>
            </section>

            <section class="card token-selection">
                <h3>Primary Trading Pair</h3>
                <div class="form-grid">
                    <div class="form-group">
                        <label for="tokenIn">Token In (for Charts/Analysis):</label>
                        <select id="tokenIn" onchange="updateTokenInfo()" aria-label="Select Token In"></select>
                        <input type="text" id="customTokenIn" placeholder="Custom Token Address" aria-label="Custom Token In Address">
                        <button class="btn btn-secondary" onclick="addCustomToken('tokenIn')">Add Custom Token</button>
                        <p id="tokenInInfo" aria-live="polite">Balance: 0.0000 | Value: $0.00</p>
                    </div>
                    <div class="form-group">
                        <label for="tokenOut">Token Out (for Charts/Analysis):</label>
                        <select id="tokenOut" onchange="updateTokenInfo()" aria-label="Select Token Out"></select>
                        <input type="text" id="customTokenOut" placeholder="Custom Token Address" aria-label="Custom Token Out Address">
                        <button class="btn btn-secondary" onclick="addCustomToken('tokenOut')">Add Custom Token</button>
                        <p id="tokenOutInfo" aria-live="polite">Balance: 0.0000 | Value: $0.00</p>
                    </div>
                    <div class="form-group">
                        <label for="nativeBudgetToken">Native Budget Token:</label>
                        <select id="nativeBudgetToken" class="section-token-select"></select>
                        <label for="nativeBudgetAmount">Amount (MATIC):</label>
                        <input type="number" id="nativeBudgetAmount" value="0" min="0" step="0.01" aria-label="Native Budget Amount">
                        <label for="nativeBudgetPercent">Percent of Balance (%): <span class="hint">Enter 0.1% to 100%</span></label>
                        <input type="number" id="nativeBudgetPercent" value="1" min="0.1" max="100" step="0.1" aria-label="Native Budget Percent" title="Enter 0.1% to 100%">
                        <button class="btn btn-secondary" id="nativeBudgetApply" onclick="setNativeBudgetByPercent()">Apply % Budget</button>
                        <p id="nativeBudgetValue">Value: $0.00</p>
                        <button class="btn btn-secondary" onclick="approveNativeBudget()">Approve Native Budget</button>
                        <p id="nativeBudgetStatus">Budget: 0 MATIC</p>
                    </div>
                    <div class="form-group">
                        <label for="tokenBudgetToken">Token Budget Token:</label>
                        <select id="tokenBudgetToken" class="section-token-select"></select>
                        <label for="tokenBudgetAmount">Amount:</label>
                        <input type="number" id="tokenBudgetAmount" value="0" min="0" step="0.01" aria-label="Token Budget Amount">
                        <label for="tokenBudgetPercent">Percent of Balance (%):</label>
                        <input type="number" id="tokenBudgetPercent" value="1" min="0.1" max="100" step="0.1" aria-label="Token Budget Percent" title="Enter 0.1% to 100%">
                        <button class="btn btn-secondary" id="tokenBudgetApply" onclick="setTokenBudgetByPercent()">Apply % Budget</button>
                        <p id="tokenBudgetValue">Value: $0.00</p>
                        <button class="btn btn-secondary" onclick="approveTokenBudget()">Approve Token Budget</button>
                        <button class="btn btn-danger" onclick="revokeBudget()">Revoke Budget</button>
                        <p id="tokenBudgetStatus">Budget: 0</p>
                    </div>
                    <div class="form-group">
                        <label for="autoUpdateBudget">Auto-Update Budgets:</label>
                        <input type="checkbox" id="autoUpdateBudget" aria-label="Auto-Update Budget">
                        <label for="autoNativeBudgetAmount">Auto Native Budget (MATIC):</label>
                        <input type="number" id="autoNativeBudgetAmount" value="0.1" min="0" step="0.01" aria-label="Auto Native Budget">
                        <label for="autoTokenBudgetAmount">Auto Token Budget:</label>
                        <input type="number" id="autoTokenBudgetAmount" value="1" min="0" step="0.01" aria-label="Auto Token Budget">
                    </div>
                </div>
                <button class="btn btn-secondary" onclick="setTokens()">Set Primary Pair</button>
            </section>

            <section class="card charts" id="chartsSection">
                <h3>Market Charts</h3>
                <div class="chart-container-wrapper">
                    <div class="chart-title" id="tokenInChartTitle">Token In Chart</div>
                    <div id="tokenInChart" style="width: 100%; height: 400px;"></div>
                    <div class="chart-title" id="tokenOutChartTitle">Token Out Chart</div>
                    <div id="tokenOutChart" style="width: 100%; height: 400px;"></div>
                </div>
                <button class="btn btn-secondary" onclick="refreshCharts()">Refresh Charts</button>
                <button class="btn btn-secondary" onclick="toggleCharts()">Hide Charts</button>
            </section>

            <section class="card trading-parameters">
                <h3>Trading Parameters</h3>
                <div class="form-grid">
                    <div class="form-group">
                        <label for="profitRange">Profit Range (%):</label>
                        <input type="number" id="profitRange" value="1" min="0" max="50" step="0.1" aria-label="Profit Range Percentage">
                    </div>
                    <div class="form-group">
                        <label for="stopLoss">Stop Loss (%):</label>
                        <input type="number" id="stopLoss" value="1" min="0" max="50" step="0.1" aria-label="Stop Loss Percentage">
                    </div>
                    <div class="form-group">
                        <label for="slippage">Slippage (%):</label>
                        <input type="number" id="slippage" value="1" min="0" max="10" step="0.1" aria-label="Slippage Percentage">
                    </div>
                </div>
                <button class="btn btn-secondary" onclick="setTradingParameters()">Set Parameters</button>
            </section>

            <section class="card technical-parameters">
                <h3>Technical Analysis Parameters</h3>
                <div class="timeframe-section">
                    <label for="timeframe">Timeframe:</label>
                    <select id="timeframe" onchange="setTimeframe()" aria-label="Select Timeframe">
                        <option value="1m">1 Minute</option>
                        <option value="5m" selected>5 Minutes</option>
                        <option value="15m">15 Minutes</option>
                        <option value="1h">1 Hour</option>
                        <option value="4h">4 Hours</option>
                        <option value="1d">1 Day</option>
                    </select>
                </div>

                <div id="technicalAnalysisParams" class="form-grid">
                    <div class="form-group">
                        <label for="rsiPeriod">RSI Period:</label>
                        <input type="number" id="rsiPeriod" value="14" min="1" aria-label="RSI Period">
                        <button class="btn btn-secondary" onclick="updateTechParam('rsiPeriod')">Update</button>
                    </div>
                    <div class="form-group">
                        <label for="minRsi">Min RSI:</label>
                        <input type="number" id="minRsi" value="30" min="0" max="100" aria-label="Minimum RSI">
                        <button class="btn btn-secondary" onclick="updateTechParam('minRsi')">Update</button>
                    </div>
                    <div class="form-group">
                        <label for="maxRsi">Max RSI:</label>
                        <input type="number" id="maxRsi" value="70" min="0" max="100" aria-label="Maximum RSI">
                        <button class="btn btn-secondary" onclick="updateTechParam('maxRsi')">Update</button>
                    </div>
                    <div class="form-group">
                        <label for="macdFast">MACD Fast:</label>
                        <input type="number" id="macdFast" value="12" min="1" aria-label="MACD Fast Period">
                        <button class="btn btn-secondary" onclick="updateTechParam('macdFast')">Update</button>
                    </div>
                    <div class="form-group">
                        <label for="macdSlow">MACD Slow:</label>
                        <input type="number" id="macdSlow" value="26" min="1" aria-label="MACD Slow Period">
                        <button class="btn btn-secondary" onclick="updateTechParam('macdSlow')">Update</button>
                    </div>
                    <div class="form-group">
                        <label for="macdSignal">MACD Signal:</label>
                        <input type="number" id="macdSignal" value="9" min="1" aria-label="MACD Signal Period">
                        <button class="btn btn-secondary" onclick="updateTechParam('macdSignal')">Update</button>
                    </div>
                    <div class="form-group">
                        <label for="bbPeriod">Bollinger Bands Period:</label>
                        <input type="number" id="bbPeriod" value="20" min="1" aria-label="Bollinger Bands Period">
                        <button class="btn btn-secondary" onclick="updateTechParam('bbPeriod')">Update</button>
                    </div>
                    <div class="form-group">
                        <label for="bbStdDev">Bollinger Std Dev:</label>
                        <input type="number" id="bbStdDev" value="2" min="0.1" step="0.1" aria-label="Bollinger Standard Deviation">
                        <button class="btn btn-secondary" onclick="updateTechParam('bbStdDev')">Update</button>
                    </div>
                    <div class="form-group">
                        <label for="emaPeriod">EMA Period:</label>
                        <input type="number" id="emaPeriod" value="20" min="1" aria-label="EMA Period">
                        <button class="btn btn-secondary" onclick="updateTechParam('emaPeriod')">Update</button>
                    </div>
                    <div class="form-group">
                        <label for="volumePeriod">Volume Period:</label>
                        <input type="number" id="volumePeriod" value="14" min="1" aria-label="Volume Period">
                        <button class="btn btn-secondary" onclick="updateTechParam('volumePeriod')">Update</button>
                    </div>
                    <div class="form-group">
                        <label for="minVolumeSpike">Min Volume Spike:</label>
                        <input type="number" id="minVolumeSpike" value="1.5" min="0" step="0.1" aria-label="Minimum Volume Spike">
                        <button class="btn btn-secondary" onclick="updateTechParam('minVolumeSpike')">Update</button>
                    </div>
                    <div class="form-group">
                        <label for="patternWindow">Pattern Window:</label>
                        <input type="number" id="patternWindow" value="30" min="10" aria-label="Pattern Window">
                        <button class="btn btn-secondary" onclick="updateTechParam('patternWindow')">Update</button>
                    </div>
                </div>
                <div class="form-group">
                    <label for="ohlcvLimit">OHLCV Limit (1-1000):</label>
                    <input type="range" id="ohlcvLimit" min="1" max="1000" value="100" aria-label="OHLCV Data Limit">
                    <span id="ohlcvLimitValue">100</span>
                </div>
                <div class="form-group">
                    <label for="ohlcvToken">OHLCV Token (of selected primary pair):</label>
                    <select id="ohlcvToken" aria-label="Select OHLCV Token">
                        <option value="base_token" selected>Base Token</option>
                        <option value="quote_token">Quote Token</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="includeEmptyIntervals">Include Empty Intervals:</label>
                    <input type="checkbox" id="includeEmptyIntervals" aria-label="Include Empty Intervals" checked>
                </div>
                <div class="form-group">
                    <label for="beforeTimestamp">Before Timestamp (Unix):</label>
                    <input type="text" id="beforeTimestamp" placeholder="e.g., 1696118400" aria-label="Before Timestamp">
                </div>
                <div class="form-group">
                    <label for="network">GeckoTerminal Network:</label>
                    <input type="text" id="network" value="polygon_pos" readonly aria-label="GeckoTerminal Network">
                </div>
                <div class="form-group">
                    <label for="poolAddress">GeckoTerminal Pool (for primary pair):</label>
                    <select id="poolAddress" onchange="updateTokenDropdown()" aria-label="Select GeckoTerminal Pool"></select>
                    <button class="btn btn-secondary" onclick="showAddPoolAddressForm()">Add Custom Pool</button>
                </div>
                <div id="addPoolAddressForm" style="display:none;" class="card">
                    <h4>Add Custom Pool Address</h4>
                    <input type="text" id="newPoolAddress" placeholder="Enter Pool Address (e.g., 0x...)" aria-label="New Pool Address">
                    <p id="newPoolAddressError" style="color:red;"></p>
                    <button class="btn btn-primary" onclick="addPoolAddress()">Add Pool</button>
                    <button class="btn btn-secondary" onclick="hideAddPoolAddressForm()">Cancel</button>
                </div>
                <div class="form-group">
                    <label for="aggregate">Aggregate (for OHLCV):</label>
                    <select id="aggregate" aria-label="OHLCV Aggregate"></select>
                </div>
            </section>

            <section class="card trading-actions">
                <h3>Trading Actions</h3>
                <div class="action-buttons">
                    <div class="form-group">
                        <label for="manualNativeBuyTokenIn">Token In:</label>
                        <select id="manualNativeBuyTokenIn" class="section-token-select"></select>
                        <label for="nativeBuyAmount">Amount (MATIC):</label>
                        <input type="number" id="nativeBuyAmount" value="1" min="0" step="0.01" aria-label="Native Buy Amount in MATIC">
                        <label for="nativeAmountOutMin">Min Tokens Out:</label>
                        <input type="number" id="nativeAmountOutMin" value="0" min="0" step="0.01" aria-label="Minimum Tokens Out">
                        <button class="btn btn-buy" onclick="manualNativeBuy()">Buy (Native)</button>
                        <p id="nativeBuyResult" aria-live="polite">Result: None</p>
                    </div>
                    <div class="form-group">
                        <label for="manualTokenBuyTokenIn">Token In:</label>
                        <select id="manualTokenBuyTokenIn" class="section-token-select"></select>
                        <label for="manualTokenBuyTokenOut">Token Out:</label>
                        <select id="manualTokenBuyTokenOut" class="section-token-select"></select>
                        <label for="tokenBuyAmount">Amount:</label>
                        <input type="number" id="tokenBuyAmount" value="1" min="0" step="0.01" aria-label="Token Buy Amount">
                        <label for="tokenAmountOutMin">Min Tokens Out:</label>
                        <input type="number" id="tokenAmountOutMin" value="0" min="0" step="0.01" aria-label="Minimum Tokens Out">
                        <button class="btn btn-buy" onclick="manualTokenBuy()">Buy (Token)</button>
                        <p id="tokenBuyResult" aria-live="polite">Result: None</p>
                    </div>
                    <div class="form-group">
                        <label for="manualNativeSellTokenIn">Token In:</label>
                        <select id="manualNativeSellTokenIn" class="section-token-select"></select>
                        <label for="nativeSellAmount">Amount:</label>
                        <input type="number" id="nativeSellAmount" value="1" min="0" step="0.01" aria-label="Native Sell Amount in MATIC">
                        <label for="nativeSellAmountOutMin">Min Tokens Out (MATIC):</label>
                        <input type="number" id="nativeSellAmountOutMin" value="0" min="0" step="0.01" aria-label="Minimum Tokens Out">
                        <button class="btn btn-sell" onclick="manualNativeSell()">Sell (Native)</button>
                        <p id="nativeSellResult" aria-live="polite">Result: None</p>
                    </div>
                    <div class="form-group">
                        <label for="manualTokenSellTokenIn">Token In:</label>
                        <select id="manualTokenSellTokenIn" class="section-token-select"></select>
                        <label for="manualTokenSellTokenOut">Token Out:</label>
                        <select id="manualTokenSellTokenOut" class="section-token-select"></select>
                        <label for="tokenSellAmount">Amount:</label>
                        <input type="number" id="tokenSellAmount" value="1" min="0" step="0.01" aria-label="Token Sell Amount">
                        <label for="tokenSellAmountOutMin">Min Tokens Out:</label>
                        <input type="number" id="tokenSellAmountOutMin" value="0" min="0" step="0.01" aria-label="Minimum Tokens Out">
                        <button class="btn btn-sell" onclick="manualTokenSell()">Sell (Token)</button>
                        <p id="tokenSellResult" aria-live="polite">Result: None</p>
                    </div>
                    <div class="form-group">
                        <label for="autoAmountOutMin">Min Amount Out (Auto):</label>
                        <input type="number" id="autoAmountOutMin" value="0" min="0" step="0.01" aria-label="Auto Min Amount Out">
                        <button id="toggleAutoTrading" class="btn btn-toggle" onclick="toggleAutoTrading()">Toggle Auto-Trading (Off)</button>
                        <p id="autoTradeResult" aria-live="polite">Auto-Trade Result: None</p>
                    </div>
                </div>
            </section>

            <section class="card signals-table">
                <h3>Market Signals</h3>
                <button class="btn btn-primary" onclick="updateSignal()">Get Market Signal</button>
                <table id="tokenSignals">
                    <thead>
                        <tr>
                            <th>Token</th>
                            <th>Final Signal</th>
                            <th>Bullish Signals üíö</th>
                            <th>Bearish Signals ‚ô•Ô∏è</th>
                            <th>Neutral Signals ‚ö™</th>
                            <th>Technical Details</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
                <p id="analysisResult" aria-live="polite">Market Analysis: Loading...</p>
                <div id="signalDetails" style="font-size: 0.9em; margin-top: 10px;"></div>
            </section>

            <section class="card wallet-balances">
                <h3>Wallet Balances</h3>
                <table id="walletBalances">
                    <thead>
                        <tr>
                            <th>Token</th>
                            <th>Balance</th>
                            <th>USD Value</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </section>

            <section class="card funding-actions">
                <h3>Funding</h3>
                <div class="form-grid">
                    <div class="form-group">
                        <label for="topUpNativeAmount">Top-Up Native Amount (MATIC):</label>
                        <input type="number" id="topUpNativeAmount" value="0" min="0" step="0.01" aria-label="Top-Up Native Amount">
                        <p id="topUpNativeValue" aria-live="polite">Value: $0.00</p>
                        <button class="btn btn-secondary" onclick="topUpNative()">Top Up Native</button>
                        <p id="topUpNativeResult" aria-live="polite">Result: None</p>
                    </div>
                    <div class="form-group">
                        <label for="topUpToken">Top-Up Token:</label>
                        <select id="topUpToken" class="section-token-select" aria-label="Select Token for Top-Up"></select>
                        <label for="topUpTokenAmount">Amount:</label>
                        <input type="number" id="topUpTokenAmount" value="0" min="0" step="0.01" aria-label="Top-Up Token Amount">
                        <p id="topUpTokenValue" aria-live="polite">Value: $0.00</p>
                        <button class="btn btn-secondary" onclick="topUpToken()">Top Up Token</button>
                        <p id="topUpTokenResult" aria-live="polite">Result: None</p>
                    </div>
                    <div class="form-group">
                        <label for="withdrawToken">Withdraw Token:</label>
                        <select id="withdrawToken" class="section-token-select" aria-label="Select Token for Withdrawal"></select>
                        <label for="withdrawAmount">Amount:</label>
                        <input type="number" id="withdrawAmount" value="0" min="0" step="0.01" aria-label="Withdraw Amount">
                        <p id="withdrawValue" aria-live="polite">Value: $0.00</p>
                        <button class="btn btn-secondary" onclick="withdrawFunds()">Withdraw</button>
                        <p id="withdrawResult" aria-live="polite">Result: None</p>
                    </div>
                </div>
            </section>

            <section class="card log-area">
                <h3>Transaction Logs</h3>
                <table id="logTable">
                    <thead>
                        <tr>
                            <th>Timestamp</th>
                            <th>Event</th>
                            <th>Details</th>
                            <th>Tx Hash</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </section>
        </main>

        <div id="loadingModal" class="modal" style="display: none;">
            <div class="modal-content">
                <p>Loading...</p>
            </div>
        </div>

        <div id="customModal" class="modal" style="display: none;">
            <div class="modal-content">
                <p id="customModalMessage"></p>
                <input type="text" id="customModalInput" style="display:none;">
                <button id="customModalConfirm" onclick="handleCustomModalConfirm()">OK</button>
                <button id="customModalCancel" onclick="handleCustomModalCancel()" style="display:none;">Cancel</button>
            </div>
        </div>
    </div>
    <script>
        // Constants
        const CONTRACT_ADDRESS = '0x56672b9dde9d6d10cd5dd10fc8579a425c24ac02';
        const QUICKSWAP_ROUTER = '0xa5E0829CaCEd8fFDD4De3c43696c57F7D7A678ff';
        const NATIVE_ADDRESS = '0x0000000000000000000000000000000000000000'; // Represents native MATIC
        const POLYGONSCAN_URL = 'https://polygonscan.com/tx/';
        const PUBLIC_RPC_URL = 'https://polygon-rpc.com';
        const POLYGON_CHAIN_ID = '137';
        const publicWeb3 = new Web3(new Web3.providers.HttpProvider(PUBLIC_RPC_URL));
        const QUICKSWAP_SUBGRAPH_URL = 'https://api.thegraph.com/subgraphs/name/sameepsi/quickswap06'; // Not directly used in the provided JS
        const BASE_TOKEN_ADDRESS = '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174'; // USDC on Polygon (as a reference)
        const WMATIC_ADDRESS = '0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270'; // WMATIC as fallback

        // Token list with metadata
        const TOKENS = [
            { name: 'USDT', address: '0xc2132D05D31c914a87C6611C10748AEb04B58e8F', decimals: 6},
            { name: 'USDC', address: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174', decimals: 6},
            { name: 'DAI', address: '0x8f3Cf7ad23Cd3CaDbD9735AFf958023239c6A063', decimals: 18},
            { name: 'WPOL', address: '0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270', decimals: 18},
            { name: 'POL (NATIVE)', address: NATIVE_ADDRESS, decimals: 18},
            { name: 'ADA', address: '0xE6a991fF0bf2C1a599c7057b7865b03aC15bF4B2', decimals: 18},
            { name: 'WETH', address: '0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619', decimals: 18},
            { name: 'WBTC', address: '0x1BFD67037B42Cf73acF2047067bd4F2C47D9BfD6', decimals: 8}
        ];

        // GeckoTerminal API Integration for Prices and OHLCV
        const GECKOTERMINAL_API_BASE = 'https://api.geckoterminal.com/api/v2';
        const POLYGON_NETWORK = 'polygon_pos';

        // Mapping of token addresses to GeckoTerminal pool addresses (example mapping, adjust as needed)
        // This mapping is crucial for fetching OHLCV data for specific token pairs.
        // For simplicity, I'm using a single pool for each token, assuming it's paired with a common asset (e.g., USDT/USDC/WMATIC).
        // In a real scenario, you'd need to identify the specific pool for the tokenIn/tokenOut pair.
        const TOKEN_POOL_MAPPING = {
            '0xc2132D05D31c914a87C6611C10748AEb04B58e8F': '0x7d747c0c41e5e4f012e06d7c077e6d81c9dd7b0', // USDT/WMATIC (example)
            '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174': '0x45c32fa1aa413f8b2d6b5b442bc5d5b7c4c8a7a', // USDC/WMATIC (example)
            '0x8f3Cf7ad23Cd3CaDbD9735AFf958023239c6A063': '0x7b9a2d37db0c4e2b0b5c7e0b6d48e2f5a7b5e5e', // DAI/WMATIC (example)
            '0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270': '0x0e9b89007e6931d5b91f4b0e1d0c2c149e0d2f0', // WMATIC/USDC (example)
            '0x0000000000000000000000000000000000000000': '0x0e9b89007e6931d5b91f4b0e1d0c2c149e0d2f0', // POL (NATIVE) maps to WMATIC pool (example)
            '0xE6a991fF0bf2C1a599c7057b7865b03aC15bF4B2': '0x3f9a8b904d8d24d4e4b6d5d2e5d8f7e2f5c2f5c', // ADA/WMATIC (example)
            '0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619': '0xf6422b997c7f54d1c6a6e103bcb1499eea0a7046', // WETH/USDT (example)
            '0x1BFD67037B42Cf73acF2047067bd4F2C47D9BfD6': '0x7f9a8b904d8d24d4e4b6d5d2e5d8f7e2f5c2f5e'  // WBTC/USDC (example)
        };

        // Global variables
        let web3, account, contract;
        let isConnected = false;
        let autoTradingActive = false;
        let autoTradingInterval;
        let tokenIn, tokenOut, tokenInDecimals, tokenOutDecimals; // These are for the PRIMARY trading pair
        let timeframe = '5m';
        let tradingParams = { profitRange: 1, stopLoss: 1, slippage: 1 };
        let techParams = {
            rsiPeriod: 14, minRsi: 30, maxRsi: 70,
            macdFast: 12, macdSlow: 26, macdSignal: 9,
            bbPeriod: 20, bbStdDev: 2,
            emaPeriod: 20, volumePeriod: 14, minVolumeSpike: 1.5,
            patternWindow: 30
        };
        let dailyPnL = 0;
        // Chart instances and series variables
        let tokenInChart;
        let tokenInCandleSeries;
        let tokenInEmaSeries;
        let tokenInBbUpperSeries;
        let tokenInBbLowerSeries;

        let tokenOutChart;
        let tokenOutCandleSeries;
        let tokenOutEmaSeries;
        let tokenOutBbUpperSeries;
        let tokenOutBbLowerSeries;

        let logs = [];

        // Custom Modal State
        let customModalResolve;

        // Update OHLCV limit display
        document.getElementById('ohlcvLimit').addEventListener('input', (e) => {
            document.getElementById('ohlcvLimitValue').textContent = e.target.value;
        });

        // Contract ABI
        const CONTRACT_ABI = [
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "_router",
                        "type": "address"
                    },
                    {
                        "internalType": "address",
                        "name": "_wrappedNative",
                        "type": "address"
                    }
                ],
                "stateMutability": "nonpayable",
                "type": "constructor"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "owner",
                        "type": "address"
                    }
                ],
                "name": "OwnableInvalidOwner",
                "type": "error"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "account",
                        "type": "address"
                    }
                ],
                "name": "OwnableUnauthorizedAccount",
                "type": "error"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": false,
                        "internalType": "bool",
                        "name": "enabled",
                        "type": "bool"
                    }
                ],
                "name": "AutoTradingToggled",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "token",
                        "type": "address"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "amount",
                        "type": "uint256"
                    }
                ],
                "name": "BudgetApproved",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "token",
                        "type": "address"
                    }
                ],
                "name": "BudgetRevoked",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "previousOwner",
                        "type": "address"
                    },
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "newOwner",
                        "type": "address"
                    }
                ],
                "name": "OwnershipTransferred",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": false,
                        "internalType": "address",
                        "name": "account",
                        "type": "address"
                    }
                ],
                "name": "Paused",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "priceFeedIn",
                        "type": "address"
                    },
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "priceFeedOut",
                        "type": "address"
                    }
                ],
                "name": "PriceFeedsUpdated",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "tokenIn",
                        "type": "address"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "amountIn",
                        "type": "uint256"
                    },
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "tokenOut",
                        "type": "address"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "amountOut",
                        "type": "uint256"
                    },
                    {
                        "indexed": false,
                        "internalType": "int256",
                        "name": "usdProfit",
                        "type": "int256"
                    }
                ],
                "name": "Swapped",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "tokenIn",
                        "type": "address"
                    },
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "tokenOut",
                        "type": "address"
                    }
                ],
                "name": "TokensUpdated",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "token",
                        "type": "address"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "amount",
                        "type": "uint256"
                    }
                ],
                "name": "ToppedUp",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": false,
                        "internalType": "address",
                        "name": "account",
                        "type": "address"
                    }
                ],
                "name": "Unpaused",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "token",
                        "type": "address"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "amount",
                        "type": "uint256"
                    }
                ],
                "name": "Withdrawn",
                "type": "event"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "amount",
                        "type": "uint256"
                    }
                ],
                "name": "approveNativeBudget",
                "outputs": [],
                "stateMutability": "payable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "token",
                        "type": "address"
                    },
                    {
                        "internalType": "uint256",
                        "name": "amount",
                        "type": "uint256"
                    }
                ],
                "name": "approveTokenBudget",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "amountIn",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "amountOutMin",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "minUSDValueOut",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "deadline",
                        "type": "uint256"
                    }
                ],
                "name": "autoNativeSwap",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "amountIn",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "amountOutMin",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "minUSDValueOut",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "deadline",
                        "type": "uint256"
                    }
                ],
                "name": "autoTokenSwap",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "",
                        "type": "address"
                    }
                ],
                "name": "autoTradeBudget",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "autoTradingEnabled",
                "outputs": [
                    {
                        "internalType": "bool",
                        "name": "",
                        "type": "bool"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "getBalance",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "nativeBalance",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "amountIn",
                        "type": "uint256"
                    }
                ],
                "name": "getExpectedOutput",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "priceFeed",
                        "type": "address"
                    }
                ],
                "name": "getUSDPrice",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "amount",
                        "type": "uint256"
                    },
                    {
                        "internalType": "address",
                        "name": "priceFeed",
                        "type": "address"
                    }
                ],
                "name": "getUSDValue",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "amountIn",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "amountOutMin",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "minUSDValueOut",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "deadline",
                        "type": "uint256"
                    }
                ],
                "name": "manualNativeSwap",
                "outputs": [],
                "stateMutability": "payable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "amountIn",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "amountOutMin",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "minUSDValueOut",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "deadline",
                        "type": "uint256"
                    }
                ],
                "name": "manualTokenSwap",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "owner",
                "outputs": [
                    {
                        "internalType": "address",
                        "name": "",
                        "type": "address"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "pause",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "paused",
                "outputs": [
                    {
                        "internalType": "bool",
                        "name": "",
                        "type": "bool"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "priceFeedIn",
                "outputs": [
                    {
                        "internalType": "contract AggregatorV3Interface",
                        "name": "",
                        "type": "address"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "priceFeedOut",
                "outputs": [
                    {
                        "internalType": "contract AggregatorV3Interface",
                        "name": "",
                        "type": "address"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "renounceOwnership",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "revokeBudget",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "router",
                "outputs": [
                    {
                        "internalType": "contract IUniswapV2Router",
                        "name": "",
                        "type": "address"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "_priceFeedIn",
                        "type": "address"
                    },
                    {
                        "internalType": "address",
                        "name": "_priceFeedOut",
                        "type": "address"
                    }
                ],
                "name": "setPriceFeeds",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "_tokenIn",
                        "type": "address"
                    },
                    {
                        "internalType": "address",
                        "name": "_tokenOut",
                        "type": "address"
                    }
                ],
                "name": "setTokens",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "bool",
                        "name": "enable",
                        "type": "bool"
                    }
                ],
                "name": "toggleAutoTrading",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "tokenIn",
                "outputs": [
                    {
                        "internalType": "address",
                        "name": "",
                        "type": "address"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "tokenOut",
                "outputs": [
                    {
                        "internalType": "address",
                        "name": "",
                        "type": "address"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "topUpNative",
                "outputs": [],
                "stateMutability": "payable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "token",
                        "type": "address"
                    },
                    {
                        "internalType": "uint256",
                        "name": "amount",
                        "type": "uint256"
                    }
                ],
                "name": "topUpToken",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "newOwner",
                        "type": "address"
                    }
                ],
                "name": "transferOwnership",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "unpause",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "token",
                        "type": "address"
                    },
                    {
                        "internalType": "uint256",
                        "name": "amount",
                        "type": "uint256"
                    }
                ],
                "name": "withdraw",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "wrappedNative",
                "outputs": [
                    {
                        "internalType": "address",
                        "name": "",
                        "type": "address"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "stateMutability": "payable",
                "type": "receive"
            }
        ];

        // ERC-20 ABI
        const ERC20_ABI = [
            {
                "constant": true,
                "inputs": [],
                "name": "name",
                "outputs": [{ "name": "", "type": "string" }],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "constant": true,
                "inputs": [],
                "name": "symbol",
                "outputs": [{ "name": "", "type": "string" }],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "constant": true,
                "inputs": [],
                "name": "decimals",
                "outputs": [{ "name": "", "type": "uint8" }],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "constant": true,
                "inputs": [{ "name": "_owner", "type": "address" }],
                "name": "balanceOf",
                "outputs": [{ "name": "balance", "type": "uint256" }],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "constant": false,
                "inputs": [
                    { "name": "_spender", "type": "address" },
                    { "name": "_value", "type": "uint256" }
                ],
                "name": "approve",
                "outputs": [{ "name": "", "type": "bool" }],
                "stateMutability": "nonpayable",
                "type": "function"
            }
        ];

        // Chainlink AggregatorV3Interface ABI (Provided in previous part, kept for completeness)
        const CHAINLINK_ABI = [
            {
                "inputs": [],
                "name": "decimals",
                "outputs": [{ "internalType": "uint8", "name": "", "type": "uint8" }],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "latestRoundData",
                "outputs": [
                    { "internalType": "uint80", "name": "roundId", "type": "uint80" },
                    { "internalType": "int256", "name": "answer", "type": "int256" },
                    { "internalType": "uint256", "name": "startedAt", "type": "uint256" },
                    { "internalType": "uint256", "name": "updatedAt", "type": "uint256" },
                    { "internalType": "uint80", "name": "answeredInRound", "type": "uint80" }
                ],
                "stateMutability": "view",
                "type": "function"
            }
        ];

        // Utility Functions
        function showLoading(show) {
            document.getElementById('loadingModal').style.display = show ? 'flex' : 'none';
        }

        // Custom Alert/Prompt Modal
        function customAlert(message) {
            return new Promise(resolve => {
                const modal = document.getElementById('customModal');
                document.getElementById('customModalMessage').textContent = message;
                document.getElementById('customModalInput').style.display = 'none';
                document.getElementById('customModalCancel').style.display = 'none';
                document.getElementById('customModalConfirm').textContent = 'OK';
                modal.style.display = 'flex';
                customModalResolve = resolve;
            });
        }

        function customPrompt(message, defaultValue = '') {
            return new Promise(resolve => {
                const modal = document.getElementById('customModal');
                document.getElementById('customModalMessage').textContent = message;
                const input = document.getElementById('customModalInput');
                input.value = defaultValue;
                input.style.display = 'block';
                document.getElementById('customModalCancel').style.display = 'inline-block';
                document.getElementById('customModalConfirm').textContent = 'Confirm';
                modal.style.display = 'flex';
                customModalResolve = resolve;
            });
        }

        function handleCustomModalConfirm() {
            const input = document.getElementById('customModalInput');
            const value = input.style.display === 'block' ? input.value : true; // true for alert, input.value for prompt
            document.getElementById('customModal').style.display = 'none';
            if (customModalResolve) {
                customModalResolve(value);
            }
        }

        function handleCustomModalCancel() {
            document.getElementById('customModal').style.display = 'none';
            if (customModalResolve) {
                customModalResolve(false); // For prompt, resolve with false on cancel
            }
        }

        function addLog(event, details, txHash = '') {
            const timestamp = new Date().toLocaleString();
            logs.push({ timestamp, event, details, txHash });
            if (logs.length > 100) logs.shift(); // Keep log table from growing indefinitely
            updateLogTable();
        }

        function updateLogTable() {
            const tbody = document.getElementById('logTable').querySelector('tbody');
            tbody.innerHTML = '';
            logs.slice().reverse().forEach(log => { // Display most recent logs first
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${log.timestamp}</td>
                    <td>${log.event}</td>
                    <td>${log.details}</td>
                    <td>${log.txHash ? `<a href="${POLYGONSCAN_URL}${log.txHash}" target="_blank">${log.txHash.substring(0, 10)}...</a>` : ''}</td>
                `;
                tbody.appendChild(row);
            });
        }

        async function initializeDropdowns() {
            // Dropdowns for primary trading pair (charts/analysis)
            const primaryPairDropdowns = ['tokenIn', 'tokenOut'];
            primaryPairDropdowns.forEach(id => {
                const select = document.getElementById(id);
                select.innerHTML = '<option value="" disabled selected>Select Token</option>';
                TOKENS.forEach(token => {
                    const option = document.createElement('option');
                    option.value = token.address;
                    option.textContent = token.name;
                    select.appendChild(option);
                });
            });

            // Dropdowns for section-specific actions (manual trades, funding)
            const sectionSpecificDropdowns = [
                'nativeBudgetToken', 'tokenBudgetToken',
                'manualNativeBuyTokenIn',
                'manualTokenBuyTokenIn', 'manualTokenBuyTokenOut',
                'manualNativeSellTokenIn',
                'manualTokenSellTokenIn', 'manualTokenSellTokenOut',
                'topUpToken', 'withdrawToken'
            ];
            sectionSpecificDropdowns.forEach(id => {
                const select = document.getElementById(id);
                select.innerHTML = '<option value="" disabled selected>Select Token</option>';
                TOKENS.forEach(token => {
                    const option = document.createElement('option');
                    option.value = token.address;
                    option.textContent = token.name;
                    select.appendChild(option);
                });
            });

            populatePoolAddressDropdown(); // Initialize pool address dropdown
        }

        async function updateTokenInfo() {
            if (!isConnected || !account) return;
            showLoading(true);
            try {
                // Read from the primary tokenIn/tokenOut selectors
                const tokenInSelect = document.getElementById('tokenIn');
                const tokenOutSelect = document.getElementById('tokenOut');
                tokenIn = tokenInSelect.value; // Update global tokenIn
                tokenOut = tokenOutSelect.value; // Update global tokenOut

                if (tokenIn === tokenOut && tokenIn !== '') {
                    await customAlert('Token In and Token Out cannot be the same for the primary trading pair.');
                    tokenInSelect.value = '';
                    tokenOut = '';
                    return;
                }

                const tokenInData = TOKENS.find(t => t.address === tokenIn);
                const tokenOutData = TOKENS.find(t => t.address === tokenOut);
                tokenInDecimals = tokenInData ? tokenInData.decimals : 18;
                tokenOutDecimals = tokenOutData ? tokenOutData.decimals : 18;

                const tokenInInfo = document.getElementById('tokenInInfo');
                const tokenOutInfo = document.getElementById('tokenOutInfo');

                let tokenInBalance = 0, tokenOutBalance = 0;
                if (tokenIn) {
                    tokenInBalance = tokenIn === NATIVE_ADDRESS
                        ? Number(web3.utils.fromWei(await web3.eth.getBalance(account), 'ether'))
                        : Number(web3.utils.fromWei(await getTokenBalance(tokenIn, account), getWeiUnit(tokenInDecimals)));
                }
                if (tokenOut) {
                    tokenOutBalance = tokenOut === NATIVE_ADDRESS
                        ? Number(web3.utils.fromWei(await web3.eth.getBalance(account), 'ether'))
                        : Number(web3.utils.fromWei(await getTokenBalance(tokenOut, account), getWeiUnit(tokenOutDecimals)));
                }

                const tokenInPrice = await getGeckoTerminalPrice(tokenIn);
                const tokenOutPrice = await getGeckoTerminalPrice(tokenOut);
                tokenInInfo.textContent = `Balance: ${tokenInBalance.toFixed(4)} | Value: $${(tokenInBalance * tokenInPrice).toFixed(2)}`;
                tokenOutInfo.textContent = `Balance: ${tokenOutBalance.toFixed(4)} | Value: $${(tokenOutBalance * tokenOutPrice).toFixed(2)}`;
            } catch (error) {
                console.error('Error updating token info:', error);
                addLog('Error', 'Failed to update token info');
            } finally {
                showLoading(false);
            }
        }

        async function getTokenBalance(tokenAddress, account) {
            if (tokenAddress === NATIVE_ADDRESS) {
                return await web3.eth.getBalance(account);
            }
            const tokenContract = new web3.eth.Contract(ERC20_ABI, tokenAddress);
            return await tokenContract.methods.balanceOf(account).call();
        }

        function getWeiUnit(decimals) {
            const units = { 18: 'ether', 6: 'mwei', 9: 'gwei' };
            return units[decimals] || 'ether';
        }

        // Cache for token prices to reduce API calls
        let priceCache = new Map();

        // Fetch gas price from the network with fallback
        async function getGasPrice() {
            try {
                const gasPrice = await web3.eth.getGasPrice();
                // Convert to gwei for display/logging (9 decimals)
                const gasPriceInGwei = web3.utils.fromWei(gasPrice, 'gwei');
                addLog('Gas Price Fetched', `Current gas price: ${gasPriceInGwei} gwei`);
                return gasPrice;
            } catch (error) {
                console.error('Error fetching gas price:', error);
                addLog('Error', 'Failed to fetch gas price, using default');
                // Default to 30 gwei (30 * 10^9 wei)
                return web3.utils.toWei('30', 'gwei');
            }
        }

        // Fetch token price from GeckoTerminal with caching
        async function getGeckoTerminalPrice(tokenAddress) {
            const cacheKey = `${tokenAddress}-${new Date().toISOString().split('T')[0]}`;
            if (priceCache.has(cacheKey)) {
                return priceCache.get(cacheKey);
            }

            try {
                // For native token, use WMATIC pool price as a proxy
                const targetAddress = tokenAddress === NATIVE_ADDRESS ? WMATIC_ADDRESS : tokenAddress;
                const poolId = TOKEN_POOL_MAPPING[targetAddress];
                if (!poolId) {
                    console.warn(`No GeckoTerminal pool mapping for token: ${targetAddress}`);
                    addLog('Warning', `No pool mapping for token ${targetAddress}`);
                    return 0;
                }
                // GeckoTerminal API for a specific pool's data
                const response = await axios.get(`${GECKOTERMINAL_API_BASE}/networks/${POLYGON_NETWORK}/pools/${poolId}`);
                const price = Number(response.data.data.attributes.base_token_price_usd) || 0; // Use base_token_price_usd for simplicity
                priceCache.set(cacheKey, price);
                return price;
            } catch (error) {
                console.error(`Error fetching price for token ${tokenAddress}:`, error);
                addLog('Error', `Failed to fetch price for token ${tokenAddress}`);
                return 0;
            }
        }

        async function connectWallet() {
            if (!window.ethereum) {
                await customAlert('MetaMask is required. Please install it from https://metamask.io.');
                return;
            }
            showLoading(true);
            try {
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                if (!web3) {
                    web3 = new Web3(window.ethereum);
                }
                account = accounts[0];
                const chainId = await web3.eth.getChainId();
                if (chainId !== parseInt(POLYGON_CHAIN_ID)) {
                    await window.ethereum.request({
                        method: 'wallet_switchEthereumChain',
                        params: [{ chainId: web3.utils.toHex(POLYGON_CHAIN_ID) }]
                    });
                }
                contract = new web3.eth.Contract(CONTRACT_ABI, CONTRACT_ADDRESS);
                isConnected = true;
                document.getElementById('connectButton').style.display = 'none';
                document.getElementById('disconnectButton').style.display = 'block';
                document.getElementById('walletStatus').textContent = `Wallet: ${account.substring(0, 6)}...${account.substring(account.length - 4)}`;
                document.getElementById('contractStatus').textContent = 'Contract Status: Connected';
                await updateContractStatus();
                await updateTokenInfo(); // Updates global tokenIn/tokenOut info
                await updateNativeBalance();
                await updateWalletBalances();
                await updateBudgetValues();
                await refreshCharts(); // Initial chart refresh on connect
                await updateSignal(); // Initial signal analysis on connect

                addLog('Wallet Connected', `Connected to ${account}`);
            } catch (error) {
                console.error('Error connecting wallet:', error);
                addLog('Error', 'Failed to connect wallet');
                await customAlert('Failed to connect wallet: ' + error.message);
            } finally {
                showLoading(false);
            }
        }

        function disconnectWallet() {
            isConnected = false;
            account = null;
            web3 = null;
            contract = null;
            document.getElementById('connectButton').style.display = 'block';
            document.getElementById('disconnectButton').style.display = 'none';
            document.getElementById('walletStatus').textContent = 'Wallet: Not Connected';
            document.getElementById('nativeBalance').textContent = 'Native Balance: 0 MATIC';
            document.getElementById('contractStatus').textContent = 'Contract Status: Not Connected';
            document.getElementById('tokenInInfo').textContent = 'Balance: 0.0000 | Value: $0.00';
            document.getElementById('tokenOutInfo').textContent = 'Balance: 0.0000 | Value: $0.00';
            if (autoTradingActive) toggleAutoTrading(); // Stop auto-trading if active
            addLog('Wallet Disconnected', 'Wallet disconnected');
        }

        async function updateNativeBalance() {
            if (!isConnected || !account) return;
            try {
                const balance = await web3.eth.getBalance(account);
                document.getElementById('nativeBalance').textContent = `Native Balance: ${Number(web3.utils.fromWei(balance, 'ether')).toFixed(4)} MATIC`;
            } catch (error) {
                console.error('Error updating native balance:', error);
                addLog('Error', 'Failed to update native balance');
            }
        }

        async function updateContractStatus() {
            if (!contract) return;
            try {
                const isPaused = await contract.methods.paused().call();
                document.getElementById('contractStatus').textContent = `Contract Status: ${isPaused ? 'Paused' : 'Active'}`;
                document.getElementById('pauseButton').style.display = isPaused ? 'none' : 'block';
                document.getElementById('unpauseButton').style.display = isPaused ? 'block' : 'none';
            } catch (error) {
                console.error('Error updating contract status:', error);
                addLog('Error', 'Failed to update contract status');
            }
        }

        async function addCustomToken(field) {
            const input = document.getElementById(`custom${field.charAt(0).toUpperCase() + field.slice(1)}`);
            const address = input.value.trim();
            if (!web3.utils.isAddress(address)) {
                await customAlert('Invalid token address.');
                return;
            }
            showLoading(true);
            try {
                const tokenContract = new web3.eth.Contract(ERC20_ABI, address);
                const symbol = await tokenContract.methods.symbol().call();
                const decimals = await tokenContract.methods.decimals().call();
                TOKENS.push({ name: symbol, address, decimals: Number(decimals) });
                await initializeDropdowns(); // Re-populate all dropdowns
                document.getElementById(field).value = address; // Set the main tokenIn/tokenOut dropdown
                input.value = '';
                updateTokenInfo();
                addLog('Custom Token Added', `Added ${symbol} (${address})`);
            } catch (error) {
                console.error('Error adding custom token:', error);
                addLog('Error', 'Failed to add custom token');
                await customAlert('Failed to add custom token.');
            } finally {
                showLoading(false);
            }
        }

        async function setTokens() {
            // Use the global tokenIn and tokenOut from the main "Token Pair" section
            if (!contract || !tokenIn || !tokenOut) {
                await customAlert('Please select both Token In and Token Out for the primary pair.');
                return;
            }
            showLoading(true);
            try {
                const tx = await contract.methods.setTokens(tokenIn, tokenOut).send({ from: account });
                addLog('Primary Tokens Set', `Set Primary Token In: ${tokenIn}, Token Out: ${tokenOut}`, tx.transactionHash);
                await refreshCharts(); // Refresh charts after setting new tokens
                await updateSignal(); // Update signals after setting new tokens
            } catch (error) {
                console.error('Error setting primary tokens:', error);
                addLog('Error', 'Failed to set primary tokens');
                await customAlert('Failed to set primary tokens.');
            } finally {
                showLoading(false);
            }
        }

        function setTimeframe() {
            timeframe = document.getElementById('timeframe').value;
            refreshCharts();
            addLog('Timeframe Set', `Timeframe set to ${timeframe}`);
        }

        async function setTradingParameters() {
            const profitRange = Number(document.getElementById('profitRange').value);
            const stopLoss = Number(document.getElementById('stopLoss').value);
            const slippage = Number(document.getElementById('slippage').value);
            if (profitRange < 0 || profitRange > 50 || stopLoss < 0 || stopLoss > 50 || slippage < 0 || slippage > 10) {
                await customAlert('Invalid parameters: Profit Range 0-50%, Stop Loss 0-50%, Slippage 0-10%.');
                return;
            }
            tradingParams = { profitRange, stopLoss, slippage };
            showLoading(true);
            try {
                // Assuming contract has a setParameters function that takes these as hundredths of a percent
                const tx = await contract.methods.setParameters(
                    Math.floor(profitRange * 100),
                    Math.floor(stopLoss * 100),
                    Math.floor(slippage * 100)
                ).send({ from: account });
                addLog('Trading Parameters Set', `Profit Range: ${profitRange}%, Stop Loss: ${stopLoss}%, Slippage: ${slippage}%`, tx.transactionHash);
            } catch (error) {
                console.error('Error setting trading parameters:', error);
                addLog('Error', 'Failed to set trading parameters');
                await customAlert('Failed to set trading parameters.');
            } finally {
                showLoading(false);
            }
        }

        async function updateTechParam(paramName) {
            const value = parseFloat(document.getElementById(paramName).value);
            const inputElement = document.getElementById(paramName);

            if (isNaN(value) || value < parseFloat(inputElement.min) || (inputElement.max && value > parseFloat(inputElement.max))) {
                await customAlert(`Invalid value for ${inputElement.labels[0].textContent.replace(':', '')}. Please check min/max values.`);
                return;
            }

            techParams[paramName] = value; // Update global techParams

            try {
                // Update chart for relevant parameters (re-render charts)
                if (['rsiPeriod', 'macdFast', 'macdSlow', 'macdSignal', 'bbPeriod', 'bbStdDev', 'emaPeriod'].includes(paramName)) {
                    await refreshCharts(); // Re-render chart with new parameter
                }
                // Trigger signal update if needed
                if (['minRsi', 'maxRsi', 'volumePeriod', 'minVolumeSpike', 'patternWindow'].includes(paramName) || ['rsiPeriod', 'macdFast', 'macdSlow', 'macdSignal', 'bbPeriod', 'bbStdDev', 'emaPeriod'].includes(paramName)) {
                    await updateSignal(); // Recalculate signals
                }
                addLog('Tech Param Updated', `${paramName} updated to ${value}`);
            } catch (error) {
                console.error(`Error updating ${paramName}:`, error);
                addLog('Error', `Failed to update ${paramName}`);
            }
        }

        async function manualNativeBuy() {
            // Read tokenIn from the specific dropdown for this action
            const tradeTokenIn = document.getElementById('manualNativeBuyTokenIn').value;
            if (!contract || !tradeTokenIn || tradeTokenIn !== NATIVE_ADDRESS) {
                await customAlert('Please select POL (NATIVE) as Token In for native buy.');
                return;
            }
            // tokenOut for native buy is always the primary tokenOut from the main pair section
            const tradeTokenOut = tokenOut; // Use the global tokenOut for the target of the buy

            const amount = Number(document.getElementById('nativeBuyAmount').value);
            const amountOutMin = Number(document.getElementById('nativeAmountOutMin').value);
            const deadline = Math.floor(Date.now() / 1000) + 20 * 60; // 20 minutes from now
            if (amount <= 0 || amountOutMin < 0 || deadline <= Math.floor(Date.now() / 1000)) {
                await customAlert('Invalid input parameters.');
                return;
            }
            showLoading(true);
            try {
                const balance = await web3.eth.getBalance(account);
                const amountWei = web3.utils.toWei(amount.toString(), 'ether');
                const tokenOutData = TOKENS.find(t => t.address === tradeTokenOut);
                const amountOutMinWei = web3.utils.toWei(amountOutMin.toString(), getWeiUnit(tokenOutData.decimals));
                if (Number(balance) < Number(amountWei)) {
                    throw new Error('Insufficient MATIC balance.');
                }
                // Signal check should be for the token being bought (tradeTokenOut) or the primary tokenIn/Out pair
                // For simplicity, using the primary tokenIn's signal for now.
                const { tokenInSignal } = await analyzeMarket(); 
                if (!tokenInSignal || !tokenInSignal.finalSignal.includes('Buy')) {
                    throw new Error(`No strong buy signal detected for ${TOKENS.find(t => t.address === tokenIn).name}. Current signal: ${tokenInSignal ? tokenInSignal.finalSignal : 'N/A'}`);
                }
                const nativeBudget = Number(document.getElementById('nativeBudgetAmount').value);
                if (amount > nativeBudget) {
                    throw new Error(`Amount exceeds native budget (${nativeBudget} MATIC).`);
                }
                const gasPrice = await getGasPrice();
                const tx = await contract.methods.manualNativeSwap(
                    amountWei,
                    amountOutMinWei,
                    web3.utils.toWei('0', 'ether'), // minUSDValueOut - assuming 0 for now
                    deadline
                ).send({ from: account, value: amountWei, gasPrice });
                document.getElementById('nativeBuyResult').textContent = `Result: Success - Bought ${tokenOutData.name} with MATIC`;
                addLog('Native Buy', `Bought ${tokenOutData.name} with ${amount} MATIC`, tx.transactionHash);
                updateTokenInfo();
                updateNativeBalance();
                updateWalletBalances();
            } catch (error) {
                console.error('Error executing native buy:', error);
                document.getElementById('nativeBuyResult').textContent = `Result: Failed - ${error.message}`;
                addLog('Error', 'Failed to execute native buy');
                await customAlert('Failed to execute native buy: ' + error.message);
            } finally {
                showLoading(false);
            }
        }

        async function manualTokenBuy() {
            // Read tokenIn and tokenOut from the specific dropdowns for this action
            const tradeTokenIn = document.getElementById('manualTokenBuyTokenIn').value;
            const tradeTokenOut = document.getElementById('manualTokenBuyTokenOut').value;

            if (!contract || !tradeTokenIn || !tradeTokenOut) {
                await customAlert('Please select Token In and Token Out for token buy.');
                return;
            }
            if (tradeTokenIn === NATIVE_ADDRESS) {
                await customAlert('Token In cannot be POL (NATIVE) for token buy. Use native buy instead.');
                return;
            }
            if (tradeTokenIn === tradeTokenOut) {
                await customAlert('Token In and Token Out cannot be the same for token buy.');
                return;
            }

            const amount = Number(document.getElementById('tokenBuyAmount').value);
            const amountOutMin = Number(document.getElementById('tokenAmountOutMin').value);
            const deadline = Math.floor(Date.now() / 1000) + 20 * 60;
            if (amount <= 0 || amountOutMin < 0 || deadline <= Math.floor(Date.now() / 1000)) {
                await customAlert('Invalid input parameters.');
                return;
            }
            showLoading(true);
            try {
                const tokenInData = TOKENS.find(t => t.address === tradeTokenIn);
                const tokenOutData = TOKENS.find(t => t.address === tradeTokenOut);
                const amountWei = web3.utils.toWei(amount.toString(), getWeiUnit(tokenInData.decimals));
                const amountOutMinWei = web3.utils.toWei(amountOutMin.toString(), getWeiUnit(tokenOutData.decimals));
                const balance = await getTokenBalance(tradeTokenIn, account);
                if (Number(balance) < Number(amountWei)) {
                    throw new Error(`Insufficient ${tokenInData.name} balance.`);
                }
                // Signal check should be for the token being bought (tradeTokenOut) or the primary tokenIn/Out pair
                // For simplicity, using the primary tokenIn's signal for now.
                const { tokenInSignal } = await analyzeMarket(); 
                if (!tokenInSignal || !tokenInSignal.finalSignal.includes('Buy')) {
                    throw new Error(`No strong buy signal detected for ${TOKENS.find(t => t.address === tokenIn).name}. Current signal: ${tokenInSignal ? tokenInSignal.finalSignal : 'N/A'}`);
                }
                const tokenBudget = Number(document.getElementById('tokenBudgetAmount').value);
                if (amount > tokenBudget) {
                    throw new Error(`Amount exceeds token budget (${tokenBudget} ${tokenInData.name}).`);
                }
                const tokenContract = new web3.eth.Contract(ERC20_ABI, tradeTokenIn);
                const gasPrice = await getGasPrice();
                await tokenContract.methods.approve(CONTRACT_ADDRESS, amountWei).send({ from: account, gasPrice });
                const tx = await contract.methods.manualTokenSwap(
                    amountWei,
                    amountOutMinWei,
                    web3.utils.toWei('0', 'ether'), // minUSDValueOut - assuming 0 for now
                    deadline
                ).send({ from: account, gasPrice });
                document.getElementById('tokenBuyResult').textContent = `Result: Success - Bought ${tokenOutData.name} with ${tokenInData.name}`;
                addLog('Token Buy', `Bought ${tokenOutData.name} with ${amount} ${tokenInData.name}`, tx.transactionHash);
                updateTokenInfo();
                updateWalletBalances();
            } catch (error) {
                console.error('Error executing token buy:', error);
                document.getElementById('tokenBuyResult').textContent = `Result: Failed - ${error.message}`;
                addLog('Error', 'Failed to execute token buy');
                await customAlert('Failed to execute token buy: ' + error.message);
            } finally {
                showLoading(false);
            }
        }

        async function manualNativeSell() {
            // Read tokenIn from the specific dropdown for this action
            const tradeTokenIn = document.getElementById('manualNativeSellTokenIn').value;
            // tokenOut for native sell is always NATIVE_ADDRESS
            const tradeTokenOut = NATIVE_ADDRESS;

            if (!contract || !tradeTokenIn) {
                await customAlert('Please select Token In for native sell.');
                return;
            }
            if (tradeTokenIn === NATIVE_ADDRESS) {
                await customAlert('Token In cannot be POL (NATIVE) for native sell. You sell a token to get native.');
                return;
            }

            const amount = Number(document.getElementById('nativeSellAmount').value);
            const amountOutMin = Number(document.getElementById('nativeSellAmountOutMin').value);
            const deadline = Math.floor(Date.now() / 1000) + 20 * 60;
            if (amount <= 0 || amountOutMin < 0 || deadline <= Math.floor(Date.now() / 1000)) {
                await customAlert('Invalid input parameters.');
                return;
            }
            showLoading(true);
            try {
                const tokenInData = TOKENS.find(t => t.address === tradeTokenIn);
                const amountWei = web3.utils.toWei(amount.toString(), getWeiUnit(tokenInData.decimals));
                const amountOutMinWei = web3.utils.toWei(amountOutMin.toString(), 'ether'); // Native token is 'ether'
                const balance = await getTokenBalance(tradeTokenIn, account);
                if (Number(balance) < Number(amountWei)) {
                    throw new Error(`Insufficient ${tokenInData.name} balance.`);
                }
                // Signal check should be for the token being sold (tradeTokenIn) or the primary tokenIn/Out pair
                // For simplicity, using the primary tokenIn's signal for now.
                const { tokenInSignal } = await analyzeMarket(); 
                if (!tokenInSignal || !tokenInSignal.finalSignal.includes('Sell')) {
                    throw new Error(`No strong sell signal detected for ${TOKENS.find(t => t.address === tokenIn).name}. Current signal: ${tokenInSignal ? tokenInSignal.finalSignal : 'N/A'}`);
                }
                const tokenBudget = Number(document.getElementById('tokenBudgetAmount').value); // Assuming token budget applies to tokenIn
                if (amount > tokenBudget) {
                    throw new Error(`Amount exceeds token budget (${tokenBudget} ${tokenInData.name}).`);
                }
                const tokenContract = new web3.eth.Contract(ERC20_ABI, tradeTokenIn);
                const gasPrice = await getGasPrice();
                await tokenContract.methods.approve(CONTRACT_ADDRESS, amountWei).send({ from: account, gasPrice });
                const tx = await contract.methods.manualTokenSwap( // Assuming manualTokenSwap handles token to native
                    amountWei,
                    amountOutMinWei,
                    web3.utils.toWei('0', 'ether'), // minUSDValueOut - assuming 0 for now
                    deadline
                ).send({ from: account, gasPrice });
                document.getElementById('nativeSellResult').textContent = `Result: Success - Sold ${tokenInData.name} for MATIC`;
                addLog('Native Sell', `Sold ${amount} ${tokenInData.name} for MATIC`, tx.transactionHash);
                updateTokenInfo();
                updateNativeBalance();
                updateWalletBalances();
            } catch (error) {
                console.error('Error executing native sell:', error);
                document.getElementById('nativeSellResult').textContent = `Result: Failed - ${error.message}`;
                addLog('Error', 'Failed to execute native sell');
                await customAlert('Failed to execute native sell: ' + error.message);
            } finally {
                showLoading(false);
            }
        }

        async function manualTokenSell() {
            // Read tokenIn and tokenOut from the specific dropdowns for this action
            const tradeTokenIn = document.getElementById('manualTokenSellTokenIn').value;
            const tradeTokenOut = document.getElementById('manualTokenSellTokenOut').value;

            if (!contract || !tradeTokenIn || !tradeTokenOut) {
                await customAlert('Please select Token In and Token Out for token sell.');
                return;
            }
            if (tradeTokenOut === NATIVE_ADDRESS) {
                await customAlert('Token Out cannot be POL (NATIVE) for token sell. Use native sell instead.');
                return;
            }
            if (tradeTokenIn === tradeTokenOut) {
                await customAlert('Token In and Token Out cannot be the same for token sell.');
                return;
            }

            const amount = Number(document.getElementById('tokenSellAmount').value);
            const amountOutMin = Number(document.getElementById('tokenSellAmountOutMin').value);
            const deadline = Math.floor(Date.now() / 1000) + 20 * 60;
            if (amount <= 0 || amountOutMin < 0 || deadline <= Math.floor(Date.now() / 1000)) {
                await customAlert('Invalid input parameters.');
                return;
            }
            showLoading(true);
            try {
                const tokenInData = TOKENS.find(t => t.address === tradeTokenIn);
                const tokenOutData = TOKENS.find(t => t.address === tradeTokenOut);
                const amountWei = web3.utils.toWei(amount.toString(), getWeiUnit(tokenInData.decimals));
                const amountOutMinWei = web3.utils.toWei(amountOutMin.toString(), getWeiUnit(tokenOutData.decimals));
                const balance = await getTokenBalance(tradeTokenIn, account);
                if (Number(balance) < Number(amountWei)) {
                    throw new Error(`Insufficient ${tokenInData.name} balance.`);
                }
                // Signal check should be for the token being sold (tradeTokenIn) or the primary tokenIn/Out pair
                // For simplicity, using the primary tokenIn's signal for now.
                const { tokenInSignal } = await analyzeMarket(); 
                if (!tokenInSignal || !tokenInSignal.finalSignal.includes('Sell')) {
                    throw new Error(`No strong sell signal detected for ${TOKENS.find(t => t.address === tokenIn).name}. Current signal: ${tokenInSignal ? tokenInSignal.finalSignal : 'N/A'}`);
                }
                const tokenBudget = Number(document.getElementById('tokenBudgetAmount').value); // Assuming token budget applies to tokenIn
                if (amount > tokenBudget) {
                    throw new Error(`Amount exceeds token budget (${tokenBudget} ${tokenInData.name}).`);
                }
                const tokenContract = new web3.eth.Contract(ERC20_ABI, tradeTokenIn);
                const gasPrice = await getGasPrice();
                await tokenContract.methods.approve(CONTRACT_ADDRESS, amountWei).send({ from: account, gasPrice });
                const tx = await contract.methods.manualTokenSwap(
                    amountWei,
                    amountOutMinWei,
                    web3.utils.toWei('0', 'ether'), // minUSDValueOut - assuming 0 for now
                    deadline
                ).send({ from: account, gasPrice });
                document.getElementById('tokenSellResult').textContent = `Result: Success - Sold ${tokenInData.name} for ${tokenOutData.name}`;
                addLog('Token Sell', `Sold ${amount} ${tokenInData.name} for ${tokenOutData.name}`, tx.transactionHash);
                updateTokenInfo();
                updateWalletBalances();
            } catch (error) {
                console.error('Error executing token sell:', error);
                document.getElementById('tokenSellResult').textContent = `Result: Failed - ${error.message}`;
                addLog('Error', 'Failed to execute token sell');
                await customAlert('Failed to execute token sell: ' + error.message);
            } finally {
                showLoading(false);
            }
        }

        async function toggleAutoTrading() {
            if (!contract) {
                await customAlert('Please connect wallet and set tokens.');
                return;
            }
            showLoading(true);
            try {
                const interval = await customPrompt('Enter auto-trading interval in seconds (min 60):', '60');
                if (interval === null || interval === false) { // User cancelled prompt
                    showLoading(false);
                    return;
                }
                const intervalSec = Math.max(Number(interval) || 60, 60);

                // Call contract function to toggle auto-trading state
                const tx = await contract.methods.toggleAutoTrading(!autoTradingActive).send({ from: account });

                autoTradingActive = !autoTradingActive;
                const button = document.getElementById('toggleAutoTrading');
                button.textContent = `Toggle Auto-Trading (${autoTradingActive ? 'On' : 'Off'})`;

                if (autoTradingActive) {
                    autoTradingInterval = setInterval(autoTrade, intervalSec * 1000);
                    addLog('Auto-Trading Toggled', `Auto-Trading: Enabled with ${intervalSec}s interval`, tx.transactionHash);
                } else {
                    clearInterval(autoTradingInterval);
                    addLog('Auto-Trading Toggled', `Auto-Trading: Disabled`, tx.transactionHash);
                }
            } catch (error) {
                console.error('Error toggling auto-trading:', error);
                addLog('Error', 'Failed to toggle auto-trading');
                await customAlert('Failed to toggle auto-trading: ' + error.message);
            } finally {
                showLoading(false);
            }
        }

        async function autoTrade() {
            if (!autoTradingActive || !tokenIn || !tokenOut) return;
            showLoading(true);
            try {
                const { tokenInSignal, tokenOutSignal } = await analyzeMarket();

                const amountOutMin = Number(document.getElementById('autoAmountOutMin').value);
                const deadline = Math.floor(Date.now() / 1000) + 60 * 20; // 20 minutes from now
                const tokenOutData = TOKENS.find(t => t.address === tokenOut);
                const amountOutMinWei = web3.utils.toWei(amountOutMin.toString(), getWeiUnit(tokenOutData.decimals));
                const gasPrice = await getGasPrice();

                let tradeExecuted = false;

                // Attempt to buy tokenOut with tokenIn (if tokenIn is native or token)
                if (tokenInSignal && tokenInSignal.finalSignal.includes('Buy')) {
                    if (tokenIn === NATIVE_ADDRESS) {
                        const amount = Number(document.getElementById('autoNativeBudgetAmount').value);
                        const balance = await web3.eth.getBalance(account);
                        const amountWei = web3.utils.toWei(amount.toString(), 'ether');
                        if (Number(balance) < Number(amountWei)) {
                            throw new Error('Insufficient MATIC balance for auto-buy.');
                        }
                        const nativeBudget = Number(document.getElementById('nativeBudgetAmount').value);
                        if (amount > nativeBudget) {
                            throw new Error(`Auto-buy amount (${amount} MATIC) exceeds native budget (${nativeBudget} MATIC).`);
                        }
                        const tx = await contract.methods.autoNativeSwap(
                            amountWei,
                            amountOutMinWei,
                            web3.utils.toWei('0', 'ether'), // minUSDValueOut
                            deadline
                        ).send({ from: account, value: amountWei, gasPrice });
                        document.getElementById('autoTradeResult').textContent = `Auto-Trade Result: Bought ${tokenOutData.name} with ${amount} MATIC`;
                        addLog('Auto Trade', `Bought ${tokenOutData.name} with ${amount} MATIC`, tx.transactionHash);
                        tradeExecuted = true;
                    } else {
                        const amount = Number(document.getElementById('autoTokenBudgetAmount').value);
                        const tokenInData = TOKENS.find(t => t.address === tokenIn);
                        const amountWei = web3.utils.toWei(amount.toString(), getWeiUnit(tokenInData.decimals));
                        const balance = await getTokenBalance(tokenIn, account);
                        if (Number(balance) < Number(amountWei)) {
                            throw new Error(`Insufficient ${tokenInData.name} balance for auto-buy.`);
                        }
                        const tokenBudget = Number(document.getElementById('tokenBudgetAmount').value);
                        if (amount > tokenBudget) {
                            throw new Error(`Auto-buy amount (${amount} ${tokenInData.name}) exceeds token budget (${tokenBudget} ${tokenInData.name}).`);
                        }
                        const tokenContract = new web3.eth.Contract(ERC20_ABI, tokenIn);
                        await tokenContract.methods.approve(CONTRACT_ADDRESS, amountWei).send({ from: account, gasPrice });
                        const tx = await contract.methods.autoTokenSwap(
                            amountWei,
                            amountOutMinWei,
                            web3.utils.toWei('0', 'ether'), // minUSDValueOut
                            deadline
                        ).send({ from: account, gasPrice });
                        document.getElementById('autoTradeResult').textContent = `Auto-Trade Result: Bought ${tokenOutData.name} with ${amount} ${tokenInData.name}`;
                        addLog('Auto Trade', `Bought ${tokenOutData.name} with ${amount} ${tokenInData.name}`, tx.transactionHash);
                        tradeExecuted = true;
                    }
                }
                // Attempt to sell tokenIn for tokenOut (if tokenIn is a token and tokenOut is native or token)
                else if (tokenInSignal && tokenInSignal.finalSignal.includes('Sell')) {
                    // This logic assumes `autoTokenSwap` can also handle selling tokenIn for tokenOut.
                    // If your contract has a separate `autoSell` function, adjust here.
                    const amount = Number(document.getElementById('autoTokenBudgetAmount').value); // Amount of tokenIn to sell
                    const tokenInData = TOKENS.find(t => t.address === tokenIn);
                    const amountWei = web3.utils.toWei(amount.toString(), getWeiUnit(tokenInData.decimals));
                    const balance = await getTokenBalance(tokenIn, account);
                    if (Number(balance) < Number(amountWei)) {
                        throw new Error(`Insufficient ${tokenInData.name} balance for auto-sell.`);
                    }
                    const tokenBudget = Number(document.getElementById('tokenBudgetAmount').value);
                    if (amount > tokenBudget) {
                        throw new Error(`Auto-sell amount (${amount} ${tokenInData.name}) exceeds token budget (${tokenBudget} ${tokenInData.name}).`);
                    }
                    const tokenContract = new web3.eth.Contract(ERC20_ABI, tokenIn);
                    await tokenContract.methods.approve(CONTRACT_ADDRESS, amountWei).send({ from: account, gasPrice });
                    const tx = await contract.methods.manualTokenSwap( // Re-using autoTokenSwap for sell
                        amountWei,
                        amountOutMinWei, // This would be amountOutMin for tokenOut
                        web3.utils.toWei('0', 'ether'), // minUSDValueOut
                        deadline
                    ).send({ from: account, gasPrice });
                    document.getElementById('autoTradeResult').textContent = `Auto-Trade Result: Sold ${tokenInData.name} for ${tokenOutData.name}`;
                    addLog('Auto Trade', `Sold ${amount} ${tokenInData.name} for ${tokenOutData.name}`, tx.transactionHash);
                    tradeExecuted = true;
                }

                if (tradeExecuted) {
                    updateTokenInfo();
                    updateNativeBalance();
                    updateWalletBalances();
                } else {
                    document.getElementById('autoTradeResult').textContent = `Auto-Trade Result: No strong signal to trade.`;
                    addLog('Auto Trade', 'No strong signal to trade.');
                }
            } catch (error) {
                console.error('Error in autoTrade:', error);
                document.getElementById('autoTradeResult').textContent = `Auto-Trade Result: Failed - ${error.message}`;
                addLog('Error', `Auto-trade failed: ${error.message}`);
            } finally {
                showLoading(false);
            }
        }

        function updatePnL(profit) {
            dailyPnL += profit;
            document.getElementById('pnlStatus').textContent = `PnL: $${dailyPnL.toFixed(2)} (Since 12:00 AM WAT)`;
        }

        async function topUpNative() {
            const amount = Number(document.getElementById('topUpNativeAmount').value);
            if (amount <= 0) {
                await customAlert('Please enter a valid amount.');
                return;
            }
            showLoading(true);
            try {
                const balance = await web3.eth.getBalance(account);
                const amountWei = web3.utils.toWei(amount.toString(), 'ether');
                if (Number(balance) < Number(amountWei)) {
                    throw new Error('Insufficient MATIC balance.');
                }
                const gasPrice = await getGasPrice();
                const tx = await contract.methods.topUpNative().send({ from: account, gasPrice });
                document.getElementById('topUpNativeResult').textContent = `Result: Success - Topped up ${amount} MATIC`;
                addLog('Top Up Native', `Topped up ${amount} MATIC`, tx.transactionHash);
                updateTokenInfo();
                updateNativeBalance();
                updateWalletBalances();
            } catch (error) {
                console.error('Error topping up native:', error);
                document.getElementById('topUpNativeResult').textContent = `Result: Failed - ${error.message}`;
                addLog('Error', 'Failed to top up native');
                await customAlert('Failed to top up native.');
            } finally {
                showLoading(false);
            }
        }

        async function topUpToken() {
            const tokenAddress = document.getElementById('topUpToken').value; // Read from section-specific dropdown
            const amount = Number(document.getElementById('topUpTokenAmount').value);
            if (!tokenAddress || amount <= 0) {
                await customAlert('Please select a token and enter a valid amount.');
                return;
            }
            showLoading(true);
            try {
                const tokenData = TOKENS.find(t => t.address === tokenAddress);
                const amountWei = web3.utils.toWei(amount.toString(), getWeiUnit(tokenData.decimals));
                const balance = await getTokenBalance(tokenAddress, account);
                if (Number(balance) < Number(amountWei)) {
                    throw new Error(`Insufficient ${tokenData.name} balance.`);
                }
                const tokenContract = new web3.eth.Contract(ERC20_ABI, tokenAddress);
                const gasPrice = await getGasPrice();
                await tokenContract.methods.approve(CONTRACT_ADDRESS, amountWei).send({ from: account, gasPrice });
                const tx = await contract.methods.topUpToken(tokenAddress, amountWei).send({ from: account, gasPrice });
                document.getElementById('topUpTokenResult').textContent = `Result: Success - Topped up ${amount} ${tokenData.name}`;
                addLog('Top Up Token', `Topped up ${amount} ${tokenData.name}`, tx.transactionHash);
                updateTokenInfo();
                updateWalletBalances();
            } catch (error) {
                console.error('Error topping up token:', error);
                document.getElementById('topUpTokenResult').textContent = `Result: Failed - ${error.message}`;
                addLog('Error', 'Failed to top up token');
                await customAlert('Failed to top up token.');
            } finally {
                showLoading(false);
            }
        }

        async function withdrawFunds() {
            const tokenAddress = document.getElementById('withdrawToken').value; // Read from section-specific dropdown
            const amount = Number(document.getElementById('withdrawAmount').value);
            if (!tokenAddress || amount <= 0) {
                await customAlert('Please select a token and enter a valid amount.');
                return;
            }
            showLoading(true);
            try {
                const tokenData = TOKENS.find(t => t.address === tokenAddress);
                const amountWei = web3.utils.toWei(amount.toString(), getWeiUnit(tokenData.decimals));
                const gasPrice = await getGasPrice();
                const tx = await contract.methods.withdraw(tokenAddress, amountWei).send({ from: account, gasPrice });
                document.getElementById('withdrawResult').textContent = `Result: Success - Withdrew ${amount} ${tokenData.name}`;
                addLog('Withdraw', `Withdrew ${amount} ${tokenData.name}`, tx.transactionHash);
                updateTokenInfo();
                if (tokenAddress === NATIVE_ADDRESS) updateNativeBalance();
                updateWalletBalances();
            } catch (error) {
                console.error('Error withdrawing funds:', error);
                document.getElementById('withdrawResult').textContent = `Result: Failed - ${error.message}`;
                addLog('Error', 'Failed to withdraw funds');
                await customAlert('Failed to withdraw funds.');
            } finally {
                showLoading(false);
            }
        }

        async function pauseContract() {
            if (!contract) {
                await customAlert('Please connect wallet.');
                return;
            }
            showLoading(true);
            try {
                const gasPrice = await getGasPrice();
                const tx = await contract.methods.pause().send({ from: account, gasPrice });
                await updateContractStatus();
                addLog('Contract Paused', 'Contract has been paused', tx.transactionHash);
            } catch (error) {
                console.error('Error pausing contract:', error);
                addLog('Error', 'Failed to pause contract');
                await customAlert('Failed to pause contract.');
            } finally {
                showLoading(false);
            }
        }

        async function unpauseContract() {
            if (!contract) {
                await customAlert('Please connect wallet.');
                return;
            }
            showLoading(true);
            try {
                const gasPrice = await getGasPrice();
                const tx = await contract.methods.unpause().send({ from: account, gasPrice });
                await updateContractStatus();
                addLog('Contract Unpaused', 'Contract has been unpaused', tx.transactionHash);
            } catch (error) {
                console.error('Error unpausing contract:', error);
                addLog('Error', 'Failed to unpause contract');
                await customAlert('Failed to unpause contract.');
            } finally {
                showLoading(false);
            }
        }

        // Update wallet balances with GeckoTerminal prices
        async function updateWalletBalances() {
            if (!isConnected || !account) return;
            const tbody = document.getElementById('walletBalances').querySelector('tbody');
            tbody.innerHTML = '';
            showLoading(true);
            try {
                for (const token of TOKENS) {
                    const balance = token.address === NATIVE_ADDRESS
                        ? await web3.eth.getBalance(account)
                        : await getTokenBalance(token.address, account);
                    const balanceFormatted = Number(web3.utils.fromWei(balance, getWeiUnit(token.decimals))).toFixed(4);
                    const price = await getGeckoTerminalPrice(token.address);
                    const value = (parseFloat(balanceFormatted) * price).toFixed(2); // Ensure balanceFormatted is parsed as float
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${token.name}</td>
                        <td>${balanceFormatted}</td>
                        <td>$${value}</td>
                    `;
                    tbody.appendChild(row);
                }
            } catch (error) {
                console.error('Error updating wallet balances:', error);
                addLog('Error', 'Failed to update wallet balances');
            } finally {
                showLoading(false);
            }
        }

        // Update budget values with GeckoTerminal prices
        async function updateBudgetValues() {
            const nativeBudgetAmount = document.getElementById('nativeBudgetAmount');
            const tokenBudgetAmount = document.getElementById('tokenBudgetAmount');
            const nativeBudgetValue = document.getElementById('nativeBudgetValue');
            const tokenBudgetValue = document.getElementById('tokenBudgetValue');
            const topUpNativeValue = document.getElementById('topUpNativeValue');
            const topUpTokenValue = document.getElementById('topUpTokenValue');
            const withdrawValue = document.getElementById('withdrawValue');

            const nativeToken = TOKENS.find(t => t.address === NATIVE_ADDRESS);
            const nativePrice = await getGeckoTerminalPrice(nativeToken.address);
            const nativeAmount = Number(nativeBudgetAmount.value);
            nativeBudgetValue.textContent = `Value: $${(nativeAmount * nativePrice).toFixed(2)}`;
            topUpNativeValue.textContent = `Value: $${(Number(document.getElementById('topUpNativeAmount').value) * nativePrice).toFixed(2)}`;

            const tokenBudgetToken = document.getElementById('tokenBudgetToken').value;
            if (tokenBudgetToken) {
                const tokenPrice = await getGeckoTerminalPrice(tokenBudgetToken);
                const tokenAmount = Number(tokenBudgetAmount.value);
                tokenBudgetValue.textContent = `Value: $${(tokenAmount * tokenPrice).toFixed(2)}`;
                topUpTokenValue.textContent = `Value: $${(Number(document.getElementById('topUpTokenAmount').value) * tokenPrice).toFixed(2)}`;
            }

            const withdrawToken = document.getElementById('withdrawToken').value;
            if (withdrawToken) {
                const tokenPrice = await getGeckoTerminalPrice(withdrawToken);
                withdrawValue.textContent = `Value: $${(Number(document.getElementById('withdrawAmount').value) * tokenPrice).toFixed(2)}`;
            }
        }

        let poolAddresses = [
            { address: '0x9b08288c3be4f62bbf8d1c20ac9c5e6f9467d8b7', name: 'WPOL/USDT' },
            { address: '0x45dda9cb7c25131df268515131f647d726f50608', name: 'WETH/USDC' },
            // Add other relevant pool addresses here for initial selection
            { address: TOKEN_POOL_MAPPING[TOKENS.find(t => t.name === 'USDC').address], name: 'USDC Pool (Example)' },
            { address: TOKEN_POOL_MAPPING[TOKENS.find(t => t.name === 'POL (NATIVE)').address], name: 'MATIC Pool (Example)' }
        ];

        function populatePoolAddressDropdown() {
            const poolAddressSelect = document.getElementById('poolAddress');
            poolAddressSelect.innerHTML = '';
            poolAddresses.forEach(pool => {
                const option = document.createElement('option');
                option.value = pool.address;
                option.text = `${pool.name} (${pool.address.slice(0, 6)}...)`;
                poolAddressSelect.appendChild(option);
            });
            // Select a default pool if available
            if (poolAddresses.length > 0) {
                poolAddressSelect.value = poolAddresses[0].address;
            }
        }

        function showAddPoolAddressForm() {
            document.getElementById('addPoolAddressForm').style.display = 'block';
        }

        function hideAddPoolAddressForm() {
            document.getElementById('addPoolAddressForm').style.display = 'none';
            document.getElementById('newPoolAddressError').textContent = '';
            document.getElementById('newPoolAddress').value = '';
        }

        function addPoolAddress() {
            const newPoolAddress = document.getElementById('newPoolAddress').value.trim();
            const errorDiv = document.getElementById('newPoolAddressError');
            if (!/^0x[a-fA-F0-9]{40}$/.test(newPoolAddress)) {
                errorDiv.textContent = 'Invalid address format.';
                return;
            }
            if (poolAddresses.some(p => p.address.toLowerCase() === newPoolAddress.toLowerCase())) {
                errorDiv.textContent = 'Pool address already exists.';
                return;
            }
            poolAddresses.push({ address: newPoolAddress, name: `Custom Pool (${newPoolAddress.slice(0, 6)}...)` });
            populatePoolAddressDropdown();
            hideAddPoolAddressForm();
            addLog('Custom Pool Added', `Added pool ${newPoolAddress}`);
        }

        function updateAggregateOptions() {
            const timeframeSelect = document.getElementById('timeframe');
            const timeframeValue = timeframeSelect.value;
            const aggregateSelect = document.getElementById('aggregate');
            let options = [];

            // GeckoTerminal aggregate intervals are specific to the timeframe
            // For '1m', '5m', '15m', '1h', '4h', '1d'
            switch (timeframeValue) {
                case '1m': options = ['1']; break;
                case '5m': options = ['1', '5']; break;
                case '15m': options = ['1', '5', '15']; break;
                case '1h': options = ['1', '4', '12']; break;
                case '4h': options = ['1', '4']; break;
                case '1d': options = ['1']; break;
                default: options = ['1']; // Default to 1 for unknown or other cases
            }

            aggregateSelect.innerHTML = options.map(o => `<option value="${o}">${o}</option>`).join('');
            // Set default aggregate to 1 or the first available option
            if (options.length > 0) {
                aggregateSelect.value = options[0];
            }
        }

        // This function was problematic, it seems to be for updating token dropdowns based on a selected pool.
        // The current tokenIn/tokenOut selection is independent. I'll make it functional but note its limited integration.
        async function updateTokenDropdown() {
            const network = document.getElementById('network').value;
            const poolAddress = document.getElementById('poolAddress').value; // Corrected ID
            if (!poolAddress) return;

            try {
                // Fetch pool info to get base and quote token addresses
                const response = await axios.get(
                    `${GECKOTERMINAL_API_BASE}/networks/${network}/pools/${poolAddress}?include=base_token,quote_token`,
                    { headers: { 'Accept': 'application/json' } }
                );
                if (!response.data || !response.data.data) throw new Error('Failed to fetch pool data');

                const baseTokenAddress = response.data.data.relationships.base_token.data.id;
                const quoteTokenAddress = response.data.data.relationships.quote_token.data.id;

                // Attempt to find or add tokens to TOKENS array if they aren't already there
                const ensureTokenExists = async (address) => {
                    if (!TOKENS.some(t => t.address === address)) {
                        try {
                            const tokenContract = new publicWeb3.eth.Contract(ERC20_ABI, address);
                            const symbol = await tokenContract.methods.symbol().call();
                            const decimals = await tokenContract.methods.decimals().call();
                            TOKENS.push({ name: symbol, address, decimals: Number(decimals) });
                            addLog('New Token Identified', `Automatically added ${symbol} (${address}) from pool.`);
                        } catch (e) {
                            console.warn(`Could not get details for new token ${address}:`, e);
                            TOKENS.push({ name: address.substring(0, 6) + '...', address, decimals: 18 }); // Fallback
                        }
                    }
                };

                await ensureTokenExists(baseTokenAddress);
                await ensureTokenExists(quoteTokenAddress);

                // Re-initialize all dropdowns to include newly added tokens
                await initializeDropdowns();

                // Set the primary tokenIn and tokenOut dropdowns to the pool's tokens
                document.getElementById('tokenIn').value = baseTokenAddress;
                document.getElementById('tokenOut').value = quoteTokenAddress;
                await updateTokenInfo(); // Update balances and values for the new primary pair
                await refreshCharts(); // Refresh charts for the new primary pair
                await updateSignal(); // Update signals for the new primary pair

            } catch (error) {
                console.error('Error updating token dropdown from pool:', error);
                addLog('Error', 'Failed to update token dropdown from pool');
            }
        }

        let ohlcCache = new Map();

        // fetchOHLCV function (corrected and harmonized)
        async function fetchOHLCV(tokenAddress, currenttimeframe) {
            const network = POLYGON_NETWORK; // Fixed network
            const poolId = TOKEN_POOL_MAPPING[tokenAddress];
            if (!poolId) {
                console.warn(`No GeckoTerminal pool mapping for token: ${tokenAddress}`);
                return [];
            }

            const timeframeParam = currenttimeframe; // Use the passed timeframe
            const aggregate = document.getElementById('aggregate').value; // Get from UI
            const limit = Math.min(Math.max(1, parseInt(document.getElementById('ohlcvLimit').value) || 100), 1000); // Get from UI
            const includeEmptyIntervals = document.getElementById('includeEmptyIntervals').checked; // Get from UI
            const beforeTimestamp = document.getElementById('beforeTimestamp').value; // Get from UI

            const cacheKey = `${tokenAddress}_${timeframeParam}_${aggregate}_${limit}_${includeEmptyIntervals}_${beforeTimestamp}`;

            // Check cache
            if (ohlcCache.has(cacheKey)) {
                const cached = ohlcCache.get(cacheKey);
                // Cache for 1 minute (60000 ms)
                if (Date.now() - cached.timestamp < 60000) {
                    return cached.data;
                }
            }

            try {
                let url = `${GECKOTERMINAL_API_BASE}/networks/${network}/pools/${poolId}/ohlcv/${timeframeParam}?aggregate=${aggregate}&limit=${limit}&currency=usd`;
                if (includeEmptyIntervals) {
                    url += `&include_empty_intervals=true`;
                }
                if (beforeTimestamp) {
                    url += `&before_timestamp=${beforeTimestamp}`;
                }

                const response = await axios.get(url, {
                    headers: { 'Accept': 'application/json' },
                });

                if (!response.data?.data?.attributes?.ohlcv_list) throw new Error('No OHLCV data received from API');

                const ohlcvData = response.data.data.attributes.ohlcv_list.map(candle => ({
                    time: candle[0], // Unix timestamp in seconds
                    open: parseFloat(candle[1]),
                    high: parseFloat(candle[2]),
                    low: parseFloat(candle[3]),
                    close: parseFloat(candle[4]),
                    volume: parseFloat(candle[5]),
                }));

                // Cache result
                ohlcCache.set(cacheKey, { data: ohlcvData, timestamp: Date.now() });
                return ohlcvData;
            } catch (error) {
                console.error(`Error fetching OHLCV for ${tokenAddress}:`, error);
                addLog('Error', `Failed to fetch OHLCV for ${TOKENS.find(t => t.address === tokenAddress)?.name || tokenAddress}`);
                document.getElementById('analysisResult').textContent = 'Error fetching market data';
                return [];
            }
        }

        // Technical Analysis using ta.js
        async function analyzeMarket() {
            const signals = {};
            const analysisResultDiv = document.getElementById('analysisResult');
            const signalDetailsDiv = document.getElementById('signalDetails');
            const tokenSignalsTableBody = document.getElementById('tokenSignals').querySelector('tbody');
            tokenSignalsTableBody.innerHTML = ''; // Clear previous signals

            analysisResultDiv.textContent = 'Analyzing market...';
            signalDetailsDiv.innerHTML = '';

            const tokensToAnalyze = [];
            // Use the global tokenIn and tokenOut for analysis
            if (tokenIn) tokensToAnalyze.push({ address: tokenIn, name: TOKENS.find(t => t.address === tokenIn)?.name || 'Token In' });
            if (tokenOut && tokenOut !== tokenIn) tokensToAnalyze.push({ address: tokenOut, name: TOKENS.find(t => t.address === tokenOut)?.name || 'Token Out' });

            if (tokensToAnalyze.length === 0) {
                analysisResultDiv.textContent = 'Please select tokens to analyze in the "Primary Trading Pair" section.';
                return { tokenInSignal: null, tokenOutSignal: null };
            }

            for (const token of tokensToAnalyze) {
                try {
                    const ohlcv = await fetchOHLCV(token.address, timeframe);
                    if (!ohlcv.length) {
                        addLog('Warning', `No OHLCV data for ${token.name}`);
                        continue;
                    }

                    const closes = ohlcv.map(c => c.close);
                    const volumes = ohlcv.map(c => c.volume);

                    // Get parameters from UI (or global techParams)
                    const rsiPeriod = techParams.rsiPeriod;
                    const minRsi = techParams.minRsi;
                    const maxRsi = techParams.maxRsi;
                    const macdFast = techParams.macdFast;
                    const macdSlow = techParams.macdSlow;
                    const macdSignal = techParams.macdSignal;
                    const bbPeriod = techParams.bbPeriod;
                    const bbStdDev = techParams.bbStdDev;
                    const emaPeriod = techParams.emaPeriod;
                    const volumePeriod = techParams.volumePeriod;
                    const minVolumeSpike = techParams.minVolumeSpike;
                    const patternWindow = techParams.patternWindow;

                    // Calculate indicators
                    const rsiValues = rsi(closes, rsiPeriod);
                    const latestRSI = rsiValues.length > 0 ? rsiValues[rsiValues.length - 1] : NaN;
                    const rsiSignal = isNaN(latestRSI) ? 'Neutral' : (latestRSI < minRsi ? 'Bullish' : (latestRSI > maxRsi ? 'Bearish' : 'Neutral'));

                    const macdValues = macd(closes, macdFast, macdSlow);
                    const signalLine = macd_signal(closes, macdFast, macdSlow, macdSignal);
                    const latestMACD = (macdValues.length > 0 && signalLine.length > 0) ? (macdValues[macdValues.length - 1] - signalLine[signalLine.length - 1]) : NaN;
                    const macdSignalResult = isNaN(latestMACD) ? 'Neutral' : (latestMACD > 0 ? 'Bullish' : 'Bearish');

                    const bb = bands(closes, bbPeriod, bbStdDev);
                    const latestClose = closes[closes.length - 1];
                    const bbSignal = (bb.length > 0 && latestClose) ? (latestClose < bb[bb.length - 1][2] ? 'Bullish' : (latestClose > bb[bb.length - 1][0] ? 'Bearish' : 'Neutral')) : 'Neutral';

                    const emaValues = ema(closes, emaPeriod);
                    const emaSignal = (emaValues.length > 0 && latestClose) ? (latestClose > emaValues[emaValues.length - 1] ? 'Bullish' : 'Bearish') : 'Neutral';

                    const volumeAvg = sma(volumes, volumePeriod);
                    const latestVolumeAvg = volumeAvg.length > 0 ? volumeAvg[volumeAvg.length - 1] : NaN;
                    const latestVolume = volumes[volumes.length - 1];
                    const volumeSignal = (latestVolumeAvg && latestVolume) ? (latestVolume > latestVolumeAvg * minVolumeSpike ? 'Bullish' : 'Neutral') : 'Neutral';

                    const patternSignal = detectChartPattern(ohlcv.slice(-patternWindow));
                    const candleSignal = detectCandlestickPattern(ohlcv.slice(-3));

                    // Aggregate signals
                    const individualSignals = [
                        { name: 'RSI', signal: rsiSignal, value: isNaN(latestRSI) ? 'N/A' : latestRSI.toFixed(2) },
                        { name: 'MACD', signal: macdSignalResult, value: isNaN(latestMACD) ? 'N/A' : latestMACD.toFixed(4) },
                        { name: 'Bollinger Bands', signal: bbSignal },
                        { name: 'EMA', signal: emaSignal },
                        { name: 'Volume', signal: volumeSignal },
                        { name: 'Pattern', signal: patternSignal },
                        { name: 'Candlestick', signal: candleSignal }
                    ];

                    const bullishCount = individualSignals.filter(s => s.signal === 'Bullish').length;
                    const bearishCount = individualSignals.filter(s => s.signal === 'Bearish').length;
                    const neutralCount = individualSignals.filter(s => s.signal === 'Neutral').length;

                    let finalSignal;
                    if (bullishCount > bearishCount + 2) finalSignal = 'Strong Buy';
                    else if (bullishCount > bearishCount) finalSignal = 'Moderate Buy';
                    else if (bearishCount > bullishCount + 2) finalSignal = 'Strong Sell';
                    else if (bearishCount > bullishCount) finalSignal = 'Moderate Sell';
                    else finalSignal = 'Neutral';

                    const details = individualSignals.map(s => `${s.name}: ${s.signal} ${s.value ? `(${s.value})` : ''}`).join(', ');

                    signals[token.address] = {
                        finalSignal,
                        bullishCount,
                        bearishCount,
                        neutralCount,
                        details: individualSignals
                    };

                    // Update the table row for this token
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${token.name}</td>
                        <td class="signal-${finalSignal.toLowerCase().replace(' ', '-')}">${finalSignal}</td>
                        <td>${bullishCount}</td>
                        <td>${bearishCount}</td>
                        <td>${neutralCount}</td>
                        <td>${details}</td>
                    `;
                    tokenSignalsTableBody.appendChild(row);

                } catch (error) {
                    console.error(`Error analyzing market for ${token.name}:`, error);
                    addLog('Error', `Failed to analyze market for ${token.name}`);
                    signals[token.address] = {
                        finalSignal: 'Error',
                        bullishCount: 0,
                        bearishCount: 0,
                        neutralCount: 0,
                        details: []
                    };
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${token.name}</td>
                        <td class="signal-weak">Error</td>
                        <td>0</td>
                        <td>0</td>
                        <td>0</td>
                        <td>Failed to fetch data or analyze.</td>
                    `;
                    tokenSignalsTableBody.appendChild(row);
                }
            }

            analysisResultDiv.textContent = 'Market Analysis Complete.';
            // Return signals for both tokens
            return {
                tokenInSignal: signals[tokenIn] || null,
                tokenOutSignal: signals[tokenOut] || null
            };
        }

        // New function to update signals manually
        async function updateSignal() {
            if (!isConnected || !tokenIn || !tokenOut) {
                await customAlert('Please connect wallet and select a primary trading pair to get market signals.');
                return;
            }
            showLoading(true);
            try {
                await analyzeMarket();
                addLog('Manual Signal Update', 'Market signals refreshed.');
            } catch (error) {
                console.error('Error updating signals:', error);
                addLog('Error', 'Failed to update market signals.');
                await customAlert('Failed to update market signals: ' + error.message);
            } finally {
                showLoading(false);
            }
        }


        function detectChartPattern(ohlcv) {
            const highs = ohlcv.map(c => c.high);
            const lows = ohlcv.map(c => c.low);

            // Ensure enough data for zigzag
            if (highs.length < 5 || lows.length < 5) return 'Neutral';

            const zigzagPointsHigh = zigzag(highs, 0.05); // Using ta.js zigzag
            const zigzagPointsLow = zigzag(lows, 0.05);

            // Simplified Head and Shoulders detection on highs (bearish)
            if (zigzagPointsHigh.length >= 5) {
                const lastFive = zigzagPointsHigh.slice(-5);
                // Peak-Trough-Peak-Trough-Peak pattern
                if (
                    lastFive[0] < lastFive[2] && // Left shoulder < Head
                    lastFive[4] < lastFive[2] && // Right shoulder < Head
                    Math.abs(lastFive[0] - lastFive[4]) < lastFive[2] * 0.05 && // Shoulders roughly equal height
                    lastFive[1] < lastFive[0] && // Left trough
                    lastFive[3] < lastFive[4] // Right trough
                ) {
                    return 'Bearish (Head & Shoulders)';
                }
            }

            // Simplified Inverse Head and Shoulders detection on lows (bullish)
            if (zigzagPointsLow.length >= 5) {
                const lastFive = zigzagPointsLow.slice(-5);
                // Trough-Peak-Trough-Peak-Trough pattern
                if (
                    lastFive[0] > lastFive[2] && // Left shoulder > Head
                    lastFive[4] > lastFive[2] && // Right shoulder > Head
                    Math.abs(lastFive[0] - lastFive[4]) < lastFive[2] * 0.05 && // Shoulders roughly equal depth
                    lastFive[1] > lastFive[0] && // Left peak
                    lastFive[3] > lastFive[4] // Right peak
                ) {
                    return 'Bullish (Inverse Head & Shoulders)';
                }
            }
            return 'Neutral';
        }

        function detectCandlestickPattern(ohlcv) {
            if (ohlcv.length < 2) return 'Neutral';
            const last = ohlcv[ohlcv.length - 1];
            const prev = ohlcv[ohlcv.length - 2];

            // Bullish Engulfing
            if (
                prev.close < prev.open && // Previous candle is bearish
                last.close > last.open && // Current candle is bullish
                last.close > prev.open && // Current candle body engulfs previous candle body
                last.open < prev.close
            ) {
                return 'Bullish (Engulfing)';
            }
            // Bearish Engulfing
            if (
                prev.close > prev.open && // Previous candle is bullish
                last.close < last.open && // Current candle is bearish
                last.close < prev.open && // Current candle body engulfs previous candle body
                last.open > prev.close
            ) {
                return 'Bearish (Engulfing)';
            }
            // Doji (small body, long wicks)
            const bodySize = Math.abs(last.open - last.close);
            const totalRange = last.high - last.low;
            if (totalRange > 0 && bodySize / totalRange < 0.1) { // Body is less than 10% of total range
                return 'Neutral (Doji)';
            }
            return 'Neutral';
        }

        // Charting with Lightweight Charts
        function initializeCharts() {
            const tokenInChartDiv = document.getElementById('tokenInChart');
            const tokenOutChartDiv = document.getElementById('tokenOutChart');

            // Ensure LightweightCharts object is available
            if (typeof LightweightCharts === 'undefined' || !LightweightCharts.createChart) {
                console.error("LightweightCharts library not loaded or not ready.");
                addLog('Chart Init Error', "LightweightCharts library not loaded or not ready.");
                return;
            }

            // Initialize tokenInChart if not already initialized and its div exists
            if (!tokenInChart && tokenInChartDiv) {
                // Check if the div has dimensions before creating the chart
                if (tokenInChartDiv.clientWidth > 0 && tokenInChartDiv.clientHeight > 0) {
                    try {
                        tokenInChart = LightweightCharts.createChart(tokenInChartDiv, {
                            width: tokenInChartDiv.clientWidth,
                            height: 400, // Based on your HTML's inline style
                            layout: { backgroundColor: '#252525', textColor: '#e0e0e0' },
                            grid: { vertLines: { color: '#444' }, horzLines: { color: '#444' } },
                            timeScale: { timeVisible: true, secondsVisible: false }
                            // Add other chart options if you have them, e.g., rightPriceScale, crosshair
                        });
                        // Only add series if chart object was successfully created
                        if (tokenInChart) {
                            // *** CRITICAL CHANGE: Use addSeries for CandlestickSeries ***
                            tokenInCandleSeries = tokenInChart.addSeries(LightweightCharts.CandlestickSeries, {
                                upColor: '#26a69a',
                                downColor: '#ef5350',
                                borderVisible: false,
                                wickUpColor: '#26a69a',
                                wickDownColor: '#ef5350',
                            });
                            // *** CRITICAL CHANGE: Use addSeries for LineSeries ***
                            tokenInEmaSeries = tokenInChart.addSeries(LightweightCharts.LineSeries, { color: 'blue', lineWidth: 1 });
                            tokenInBbUpperSeries = tokenInChart.addSeries(LightweightCharts.LineSeries, { color: 'red', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dashed });
                            tokenInBbLowerSeries = tokenInChart.addSeries(LightweightCharts.LineSeries, { color: 'red', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dashed });
                            tokenInCandleSeries.applyOptions({ priceFormat: { type: 'price', precision: 4, minMove: 0.0001 } });
                        } else {
                            console.error("LightweightCharts.createChart returned null or undefined for tokenInChart.");
                            addLog('Chart Init Error', "LightweightCharts.createChart failed for tokenInChart.");
                        }
                    } catch (e) {
                        console.error("Exception creating tokenInChart:", e);
                        addLog('Chart Init Error', `Exception during tokenInChart creation: ${e.message}`);
                    }
                } else {
                    console.warn("tokenInChart div has zero dimensions. Chart not created.");
                    addLog('Chart Init Warning', "'tokenInChart' div has no dimensions.");
                }
            } else if (!tokenInChartDiv) { // This condition is if tokenInChartDiv is null from getElementById
                console.error("Error: 'tokenInChart' div not found for chart initialization.");
                addLog('Chart Init Error', "'tokenInChart' div not found.");
            }

            // Initialize tokenOutChart if not already initialized and its div exists
            if (!tokenOutChart && tokenOutChartDiv) {
                // Check if the div has dimensions before creating the chart
                if (tokenOutChartDiv.clientWidth > 0 && tokenOutChartDiv.clientHeight > 0) {
                    try {
                        tokenOutChart = LightweightCharts.createChart(tokenOutChartDiv, {
                            width: tokenOutChartDiv.clientWidth,
                            height: 400,
                            layout: { backgroundColor: '#252525', textColor: '#e0e0e0' },
                            grid: { vertLines: { color: '#444' }, horzLines: { color: '#444' } },
                            timeScale: { timeVisible: true, secondsVisible: false }
                        });
                        // Only add series if chart object was successfully created
                        if (tokenOutChart) {
                            tokenOutCandleSeries = tokenOutChart.addSeries(LightweightCharts.CandlestickSeries, {
                                upColor: '#26a69a',
                                downColor: '#ef5350',
                                borderVisible: false,
                                wickUpColor: '#26a69a',
                                wickDownColor: '#ef5350',
                            });
                            tokenOutEmaSeries = tokenOutChart.addSeries(LightweightCharts.LineSeries, { color: 'blue', lineWidth: 1 });
                            tokenOutBbUpperSeries = tokenOutChart.addSeries(LightweightCharts.LineSeries, { color: 'red', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dashed });
                            tokenOutBbLowerSeries = tokenOutChart.addSeries(LightweightCharts.LineSeries, { color: 'red', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dashed });
                            tokenOutCandleSeries.applyOptions({ priceFormat: { type: 'price', precision: 4, minMove: 0.0001 } });
                        } else {
                            console.error("LightweightCharts.createChart returned null or undefined for tokenOutChart.");
                            addLog('Chart Init Error', "LightweightCharts.createChart failed for tokenOutChart.");
                        }
                    } catch (e) {
                        console.error("Exception creating tokenOutChart:", e);
                        addLog('Chart Init Error', `Exception during tokenOutChart creation: ${e.message}`);
                    }
                } else {
                    console.warn("tokenOutChart div has zero dimensions. Chart not created.");
                    addLog('Chart Init Warning', "'tokenOutChart' div has no dimensions.");
                }
            } else if (!tokenOutChartDiv) {
                console.error("Error: 'tokenOutChart' div not found for chart initialization.");
                addLog('Chart Init Error', "'tokenOutChart' div not found.");
            }

            // Handle window resize to adjust chart size
            window.addEventListener('resize', () => {
                // Ensure charts and their divs exist before attempting to resize
                if (tokenInChart && tokenInChartDiv) {
                    tokenInChart.resize(tokenInChartDiv.clientWidth, tokenInChartDiv.clientHeight);
                }
                if (tokenOutChart && tokenOutChartDiv) {
                    tokenOutChart.resize(tokenOutChartDiv.clientWidth, tokenOutChartDiv.clientHeight);
                }
            });
        }

        // Function to update a single chart with OHLCV data and indicators
        function updateSingleChart(chartInstance, candleSeries, emaSeries, bbUpperSeries, bbLowerSeries, ohlcvData, tokenName) {
            if (!chartInstance || !candleSeries) {
                console.warn(`Chart instance or series not available for ${tokenName}. Skipping update.`);
                return;
            }

            document.getElementById(`${tokenName.replace(/\s|\(|\)/g, '')}ChartTitle`).textContent = `${tokenName} Chart`;

            // Format OHLCV data for Lightweight Charts
            const formattedOhlcv = ohlcvData.map(c => ({
                time: c.time, // Already in seconds from GeckoTerminal
                open: c.open,
                high: c.high,
                low: c.low,
                close: c.close,
            }));
            candleSeries.setData(formattedOhlcv);

            // Calculate and set EMA data
            const closes = ohlcvData.map(c => c.close);
            const emaValues = ema(closes, techParams.emaPeriod);
            const formattedEma = ohlcvData.slice(-emaValues.length).map((c, i) => ({
                time: c.time,
                value: emaValues[i],
            }));
            emaSeries.setData(formattedEma);

            // Calculate and set Bollinger Bands data
            const bb = bands(closes, techParams.bbPeriod, techParams.bbStdDev);
            const formattedBbUpper = ohlcvData.slice(-bb.length).map((c, i) => ({ time: c.time, value: bb[i][0] }));
            const formattedBbLower = ohlcvData.slice(-bb.length).map((c, i) => ({ time: c.time, value: bb[i][2] }));
            bbUpperSeries.setData(formattedBbUpper);
            bbLowerSeries.setData(formattedBbLower);

            chartInstance.timeScale().fitContent(); // Adjust time scale to fit all data
        }


        async function refreshCharts() {
            if (!tokenIn || !tokenOut) {
                addLog('Chart Refresh', 'Select Token In and Token Out in "Primary Trading Pair" section to refresh charts.');
                return;
            }
            showLoading(true);
            try {
                const tokenInData = await fetchOHLCV(tokenIn, timeframe);
                const tokenOutData = await fetchOHLCV(tokenOut, timeframe);

                // Ensure charts are initialized before updating
                if (tokenInChart && tokenInCandleSeries) {
                    updateSingleChart(tokenInChart, tokenInCandleSeries, tokenInEmaSeries, tokenInBbUpperSeries, tokenInBbLowerSeries, tokenInData, TOKENS.find(t => t.address === tokenIn).name);
                } else {
                    addLog('Chart Refresh Error', 'tokenInChart not initialized for update.');
                }

                if (tokenOutChart && tokenOutCandleSeries) {
                    updateSingleChart(tokenOutChart, tokenOutCandleSeries, tokenOutEmaSeries, tokenOutBbUpperSeries, tokenOutBbLowerSeries, tokenOutData, TOKENS.find(t => t.address === tokenOut).name);
                } else {
                    addLog('Chart Refresh Error', 'tokenOutChart not initialized for update.');
                }

                addLog('Charts Refreshed', `Updated charts for ${TOKENS.find(t => t.address === tokenIn).name} and ${TOKENS.find(t => t.address === tokenOut).name}`);
            } catch (error) {
                console.error('Error refreshing charts:', error);
                addLog('Error', 'Failed to refresh charts');
            } finally {
                showLoading(false);
            }
        }

        function toggleCharts() {
            const chartsSection = document.getElementById('chartsSection');
            const button = document.querySelector('#chartsSection button:last-of-type');
            const isHidden = chartsSection.style.display === 'none';
            chartsSection.style.display = isHidden ? 'block' : 'none';
            button.textContent = isHidden ? 'Hide Charts' : 'Show Charts';
        }

        // Budget Management Functions
        function validateBudgetInputs() {
            const nativePercent = document.getElementById('nativeBudgetPercent');
            const tokenPercent = document.getElementById('tokenBudgetPercent');
            const nativeAmount = document.getElementById('nativeBudgetAmount');
            const tokenAmount = document.getElementById('tokenBudgetAmount');

            nativePercent.classList.toggle('invalid', parseFloat(nativePercent.value) < 0.1 || parseFloat(nativePercent.value) > 100);
            tokenPercent.classList.toggle('invalid', parseFloat(tokenPercent.value) < 0.1 || parseFloat(tokenPercent.value) > 100);
            nativeAmount.classList.toggle('invalid', parseFloat(nativeAmount.value) < 0);
            tokenAmount.classList.toggle('invalid', parseFloat(tokenAmount.value) < 0);

            document.getElementById('nativeBudgetApply').disabled = nativePercent.classList.contains('invalid');
            document.getElementById('tokenBudgetApply').disabled = tokenPercent.classList.contains('invalid');
        }

        async function setNativeBudgetByPercent() {
            const percent = Number(document.getElementById('nativeBudgetPercent').value);
            if (percent < 0.1 || percent > 100) {
                await customAlert('Percent must be between 0.1% and 100%.');
                return;
            }
            showLoading(true);
            try {
                const balance = await web3.eth.getBalance(account);
                const balanceMATIC = Number(web3.utils.fromWei(balance, 'ether'));
                const budgetAmount = (balanceMATIC * percent) / 100;
                document.getElementById('nativeBudgetAmount').value = budgetAmount.toFixed(4);
                await updateBudgetValues();
                document.getElementById('nativeBudgetStatus').textContent = `Budget: ${budgetAmount.toFixed(4)} MATIC`;
                addLog('Native Budget Set', `Set native budget to ${budgetAmount.toFixed(4)} MATIC (${percent}%)`);
            } catch (error) {
                console.error('Error setting native budget:', error);
                addLog('Error', 'Failed to set native budget');
            } finally {
                showLoading(false);
            }
        }

        async function setTokenBudgetByPercent() {
            const percent = Number(document.getElementById('tokenBudgetPercent').value);
            const tokenAddress = document.getElementById('tokenBudgetToken').value;
            if (!tokenAddress || percent < 0.1 || percent > 100) {
                await customAlert('Please select a token and ensure percent is between 0.1% and 100%.');
                return;
            }
            showLoading(true);
            try {
                const tokenData = TOKENS.find(t => t.address === tokenAddress);
                const balance = await getTokenBalance(tokenAddress, account);
                const balanceFormatted = Number(web3.utils.fromWei(balance, getWeiUnit(tokenData.decimals)));
                const budgetAmount = (balanceFormatted * percent) / 100;
                document.getElementById('tokenBudgetAmount').value = budgetAmount.toFixed(4);
                await updateBudgetValues();
                document.getElementById('tokenBudgetStatus').textContent = `Budget: ${budgetAmount.toFixed(4)} ${tokenData.name}`;
                addLog('Token Budget Set', `Set ${tokenData.name} budget to ${budgetAmount.toFixed(4)} (${percent}%)`);
            } catch (error) {
                console.error('Error setting token budget:', error);
                addLog('Error', 'Failed to set token budget');
            } finally {
                showLoading(false);
            }
        }

        async function approveNativeBudget() {
            const amount = Number(document.getElementById('nativeBudgetAmount').value);
            if (amount <= 0) {
                await customAlert('Please enter a valid native budget amount.');
                return;
            }
            showLoading(true);
            try {
                const balance = await web3.eth.getBalance(account);
                const amountWei = web3.utils.toWei(amount.toString(), 'ether');
                if (Number(balance) < Number(amountWei)) {
                    throw new Error('Insufficient MATIC balance.');
                }
                const gasPrice = await getGasPrice();
                const tx = await contract.methods.approveNativeBudget(amountWei).send({ from: account, gasPrice });
                document.getElementById('nativeBudgetStatus').textContent = `Budget: ${amount.toFixed(4)} MATIC`;
                addLog('Native Budget Approved', `Approved ${amount} MATIC budget`, tx.transactionHash);
            } catch (error) {
                console.error('Error approving native budget:', error);
                addLog('Error', 'Failed to approve native budget');
                await customAlert('Failed to approve native budget.');
            } finally {
                showLoading(false);
            }
        }

        async function approveTokenBudget() {
            const tokenAddress = document.getElementById('tokenBudgetToken').value;
            const amount = Number(document.getElementById('tokenBudgetAmount').value);
            if (!tokenAddress || amount <= 0) {
                await customAlert('Please select a token and enter a valid budget amount.');
                return;
            }
            showLoading(true);
            try {
                const tokenData = TOKENS.find(t => t.address === tokenAddress);
                const amountWei = web3.utils.toWei(amount.toString(), getWeiUnit(tokenData.decimals));
                const balance = await getTokenBalance(tokenAddress, account);
                if (Number(balance) < Number(amountWei)) {
                    throw new Error(`Insufficient ${tokenData.name} balance.`);
                }
                const tokenContract = new web3.eth.Contract(ERC20_ABI, tokenAddress);
                const gasPrice = await getGasPrice();
                await tokenContract.methods.approve(CONTRACT_ADDRESS, amountWei).send({ from: account, gasPrice });
                const tx = await contract.methods.approveTokenBudget(tokenAddress, amountWei).send({ from: account, gasPrice });
                document.getElementById('tokenBudgetStatus').textContent = `Budget: ${amount.toFixed(4)} ${tokenData.name}`;
                addLog('Token Budget Approved', `Approved ${amount} ${tokenData.name} budget`, tx.transactionHash);
            } catch (error) {
                console.error('Error approving token budget:', error);
                document.getElementById('tokenBudgetStatus').textContent = `Budget: Failed`;
                addLog('Error', 'Failed to approve token budget');
                await customAlert('Failed to approve token budget.');
            } finally {
                showLoading(false);
            }
        }

        async function revokeBudget() {
            showLoading(true);
            try {
                const gasPrice = await getGasPrice();
                const tx = await contract.methods.revokeBudget().send({ from: account, gasPrice });
                document.getElementById('nativeBudgetAmount').value = '0';
                document.getElementById('tokenBudgetAmount').value = '0';
                document.getElementById('nativeBudgetStatus').textContent = 'Budget: 0 MATIC';
                document.getElementById('tokenBudgetStatus').textContent = 'Budget: 0';
                await updateBudgetValues();
                addLog('Budget Revoked', 'All budgets revoked', tx.transactionHash);
            } catch (error) {
                console.error('Error revoking budget:', error);
                addLog('Error', 'Failed to revoke budget');
                await customAlert('Failed to revoke budget.');
            } finally {
                showLoading(false);
            }
        }

        // Sidebar Toggle
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            sidebar.classList.toggle('hidden');
        }

        // Event Listeners
        window.onload = () => { // Changed from DOMContentLoaded to window.onload
            initializeDropdowns();
            initializeCharts(); // Now called after all resources are loaded
            updateAggregateOptions(); // Call initially to set options
            document.getElementById('timeframe').addEventListener('change', updateAggregateOptions); // Update on timeframe change

            // Set default token selections for better initial experience
            // Primary Pair
            document.getElementById('tokenIn').value = TOKENS.find(t => t.name === 'USDC').address;
            document.getElementById('tokenOut').value = TOKENS.find(t => t.name === 'WPOL').address;

            // Budget Tokens
            document.getElementById('nativeBudgetToken').value = NATIVE_ADDRESS;
            document.getElementById('tokenBudgetToken').value = TOKENS.find(t => t.name === 'USDC').address;

            // Manual Trading Tokens
            document.getElementById('manualNativeBuyTokenIn').value = NATIVE_ADDRESS; // Native for buy
            document.getElementById('manualTokenBuyTokenIn').value = TOKENS.find(t => t.name === 'USDC').address;
            document.getElementById('manualTokenBuyTokenOut').value = TOKENS.find(t => t.name === 'WPOL').address;
            document.getElementById('manualNativeSellTokenIn').value = TOKENS.find(t => t.name === 'USDC').address; // Token to sell for native
            document.getElementById('manualTokenSellTokenIn').value = TOKENS.find(t => t.name === 'USDC').address;
            document.getElementById('manualTokenSellTokenOut').value = TOKENS.find(t => t.name === 'WPOL').address;

            // Funding Tokens
            document.getElementById('topUpToken').value = TOKENS.find(t => t.name === 'USDC').address;
            document.getElementById('withdrawToken').value = TOKENS.find(t => t.name === 'USDC').address;


            // Update on selected token change for budget values
            document.getElementById('tokenBudgetToken').addEventListener('change', updateBudgetValues);
            document.getElementById('topUpToken').addEventListener('change', updateBudgetValues);
            document.getElementById('withdrawToken').addEventListener('change', updateBudgetValues);

            // Update values when amounts change
            document.getElementById('nativeBudgetAmount').addEventListener('input', updateBudgetValues);
            document.getElementById('tokenBudgetAmount').addEventListener('input', updateBudgetValues);
            document.getElementById('topUpNativeAmount').addEventListener('input', updateBudgetValues);
            document.getElementById('topUpTokenAmount').addEventListener('input', updateBudgetValues);
            document.getElementById('withdrawAmount').addEventListener('input', updateBudgetValues);

            // Periodic updates (excluding market analysis, now manual)
            setInterval(() => {
                if (isConnected) {
                    updateTokenInfo(); // Updates info for primary pair
                    updateNativeBalance();
                    updateWalletBalances();
                    updateBudgetValues();
                    refreshCharts(); // Keep charts updated
                }
            }, 60000); // Update every minute

            // Input validation for budgets
            document.getElementById('nativeBudgetPercent').addEventListener('input', validateBudgetInputs);
            document.getElementById('tokenBudgetPercent').addEventListener('input', validateBudgetInputs);
            document.getElementById('nativeBudgetAmount').addEventListener('input', validateBudgetInputs);
            document.getElementById('tokenBudgetAmount').addEventListener('input', validateBudgetInputs);

            // Auto-update budgets if enabled
            document.getElementById('autoUpdateBudget').addEventListener('change', async (e) => {
                if (e.target.checked) {
                    await setNativeBudgetByPercent();
                    await setTokenBudgetByPercent();
                    addLog('Auto-Update Budget', 'Auto-update budget enabled');
                }
            });
        };
    </script>
</body>
</html>
